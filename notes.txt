# Record keeping

Unfortunately I think this complicates unbonding logic a bit.
Given this reality,
1) I think the naive approach is to track user's unbondings in stakeibc module state, then transfer 
the unbonded tokens from the delegation account to the user's account as soon as the unbonding period 
ends. Staking module's unbonding-delegations object has completion_time: "2022-06-12T23:10:51.070726210Z" 
and creation_height: "390" fields that help us time this correctly -- we need to make sure we transfer 
the unbonded tokens rather than sweep them back to staking

2) A slightly better approach may be to sweep only the sum of amounts liquid staked since the last epoch 
(by summing up deposit receipts), rather than staking the entire delegation account balance. This would 
alleviate the need to transfer the funds out before delegation account token are re-staked (because the 
unbonded tokens would remain in the account until transfered to the user).

3) Another approach could be to track unbonded amounts each in a FIFO queue in stakeibc module state, 
and, at each epoch, while the balance in the delegation account is  >= the amount of the top item in 
the queue, transfer funds to that user's account and pop the queue. If the queue is emptied, stake the 
remaining funds. Haven't thought this one through fully

I vote for (2) for its simplicity, but (3) could be interesting down the line bc it allows 
unbondings in less than 21 days

# Records we need to keep




*******************************************************************
******************************DEPOSITS*****************************
*******************************************************************

# SECTION 1
[X] 0 Update DepositRecord type
  UPDATE DEPOSIT RECORD
  message DepositRecord {
    uint64 id = 1; // just an int - should work?
    int64 amount = 2; // total amount
    string denom = 3; // tokens
    string hostZoneId = 4; // can remove - fetch with denom
    // the next thing we should do
    enum RecordType {
      DEPOSIT = 0;
      REWARDS = 1;
      WITHDRAWAL = 2;
    }
    enum Status {
      TRANSFER = 0;
      STAKE = 1;
    }
    Status status = 5; 
  }
  - Add next status types
      - transfer: the balance is ready to be transferred to the host zone
      - stake: the balance is ready to be staked
[X] 1 Aggregate into a single deposit record / successful epoch / chain
      [X] add current epoch data type, update in begin hook
      [X] In the stakeibc hook
        [X] create a DepositRecord, keyed by epoch_number:chain_id in stakeibc hook
        [X] process DepositRecords from previous epochs
      [X] Update the deposit record in liquid stake (fetch the epoch id with the epochs keeper and stride epoch)
      [] Update the DepositRecord in ack
        [] If previous status was TRANSFER, update status to STAKE
        [] If previous status was STAKE, delete the record
        [] It should be easy to differentiate between these based on the ICA call issued

>>> EPOCH START
----------

# users call liquid stake
def liquidStake(tokens)
  currentRecord = getRecord(epochId)
  currentRecord.amount += tokens.amount

>>> EPOCH END
for record in depositRecords:
  hz = getHz(record)
  if record.status == TRANSFER:
    def ibcTransferAck(ack):
      if ack == success:
        record = getRecord(ack)
        delete(record)
    # add record deletion logic to ack
    ibcTransfer.ackFunction = ibcTransferAck
    # ibc transfer the tokens over
    ibcTransfer(to=hz.depositAccount(), amount=record.amount)

----------
>>> NEXT EPOCH STARTS









*******************************************************************
******************************REWARDS******************************
*******************************************************************

# SECTION 2
[] 0 Set withdrawal address of delegation account to withdrawal account in host zone
    registration ack
[] 1 Update DepositRecord to handle rewards types
[] 2 Update epoch end to process all records for each host zone
[] 3 Add new records for rewards that accrued in the previous epoch

>>> EPOCH START
----------
... rewards accrue via calls to liquid stake

>>> EPOCH END

# process all unprocessed records for each host zone
for record in records where record.type == REWARD:
  def bankSendAck(ack):
    record = getRecord(ack.id)
    record.type = DEPOSIT
    record.status = STAKE
  # do upon completion
  ICABankSend.Ack = bankSendAck
  ICABankSend(from=withdrawal, to=delegat, amount=record.amount)

# add new records for rewards that accrued in the previous epoch
for hz in getAllHostZones():
  def addRewardsRecord(hz):
    # define a query callback function
    def queryCB(hz):
      recordBalance = sumAllRewardsRecords()
      newBalance = balance - recordBalance
      createNewRewardsRecord(newBalance)
    wA = hz.withdrawalAccount()
    query(address=wA, queryType=balance, cb=queryCB)


# NOTE: this is executed after processing records because although ICA calls
# _are_ ordered (meaning we could first send balances from withdrawal -> delegate account),
# there's no way to enforce that the records are updated on stride without chaining these.
# unclear whether chaining is a robust approach. What happens if one step fails?
# what do we have to roll back?
# easier to think about these in isolation IMO
1. ICQ wA balance
2. ICQ CB: create records, BankSend ICA call them from withdrawal -> delegate account
3. Bank send ICA Ack: update deposit records, iterate through them and MsgDelegate ICA call them
4. MsgDelegate ICA ack: delete deposit records
    

----------
NEXT EPOCH START
...









*******************************************************************
******************************UNBONDING****************************
*******************************************************************

# SIMPLIFYING ASSUMPTION: Only allow users to process 1 unbonding / block
# this allows us to more easily track unique unbonding records for a user
# by keying them as senderAddress:hostZoneId:amount:block


# SECTION 3
[] 0 Add UnbondingRecord type
[] 1 Add RedeemStake logic outlined below
[] 2 Update Epoch end to
  [] a. PROCESS RECORDS - ENQUEUE
  [] b. CACHE MOST RECENT BLOCK HEIGHT FOR HOST ZONE
  [] c. PROCESS RECORDS - SEND BACK TO USERS


>>> EPOCH START
----------

# users call redeem stake
def redeemStake(tokens):
  unbondingRecord = newUnbondingRecord()
  # getUnbondingBlockHeight queries the unbonding record
  # in the creation ack and adds a dequeue unbonding height
  # if the query fails, it's kept in the pending queue
  # which we issue queries for, over and over
  unbondingRecord.blockHeight = getUnbondingBlockHeight()
  unprocessedUnbondingRecords.enqueue(unbondingRecord)

>>> EPOCH END

# PROCESS RECORDS - ENQUEUE
for record in unprocessedRecords:
  # query unbonding height
  # in ack
    # fetch record
    # delete from unprocessed records
    # add unbonding height
    # add to processed records

# CACHE MOST RECENT BLOCK HEIGHT FOR HOST ZONE
for zone in hostZones:
  client = getClient
  mostRecentBlock = client.height
  zone.mostRecentBlock = mostRecentBlock

# PROCESS RECORDS - SEND BACK TO USERS
for hostZone, recordList in recordsByHostZone:
  for record in recordList:
    if record.height > hostZone.mostRecentBlock:
      process(record)

----------
>>> NEXT EPOCH STARTS











Unbondings example response
aidansalzmann@Aidans-MacBook-Air stride % strided q staking unbonding-delegations stride1dq24k3sscq334cyp42xaczc8wha6mrg0pwvd86
pagination:
  next_key: null
  total: "0"
unbonding_responses:
- delegator_address: stride1dq24k3sscq334cyp42xaczc8wha6mrg0pwvd86
  entries:
  - balance: "5"
    completion_time: "2022-07-07T14:16:27.695113Z"
    creation_height: "2111"
    initial_balance: "5"
  - balance: "5"
    completion_time: "2022-07-07T14:17:23.723237Z"
    creation_height: "2162"
    initial_balance: "5"
  validator_address: stridevaloper1dq24k3sscq334cyp42xaczc8wha6mrg0zmg3tl



