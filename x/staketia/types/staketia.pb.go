// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stride/staketia/staketia.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status fields for a delegation record
// Note: There is an important assumption here that tokens in the deposit
// account should not be tracked by these records. The record is created as soon
// as the tokens leave stride
// Additionally, the GetActiveDelegationRecords query filters for records that
// are either TRANSFER_IN_PROGERSS or DELEGATION_QUEUE. If a new active status
// is added, the keeper must be modified
type DelegationRecordStatus int32

const (
	// TRANSFER_IN_PROGRESS indicates the native tokens are being sent from the
	// deposit account to the delegation account
	TRANSFER_IN_PROGRESS DelegationRecordStatus = 0
	// TRANSFER_FAILED indicates that the transfer either timed out or was an ack
	// failure
	TRANSFER_FAILED DelegationRecordStatus = 1
	// DELEGATION_QUEUE indicates the tokens have landed on the host zone and are
	// ready to be delegated
	DELEGATION_QUEUE DelegationRecordStatus = 2
	// DELEGATION_COMPLETE indicates the delegation has been completed
	DELEGATION_COMPLETE DelegationRecordStatus = 3
)

var DelegationRecordStatus_name = map[int32]string{
	0: "TRANSFER_IN_PROGRESS",
	1: "TRANSFER_FAILED",
	2: "DELEGATION_QUEUE",
	3: "DELEGATION_COMPLETE",
}

var DelegationRecordStatus_value = map[string]int32{
	"TRANSFER_IN_PROGRESS": 0,
	"TRANSFER_FAILED":      1,
	"DELEGATION_QUEUE":     2,
	"DELEGATION_COMPLETE":  3,
}

func (x DelegationRecordStatus) String() string {
	return proto.EnumName(DelegationRecordStatus_name, int32(x))
}

func (DelegationRecordStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{0}
}

// Status fields for an unbonding record
type UnbondingRecordStatus int32

const (
	// ACCUMULATING_REDEMPTIONS indicates redemptions are still being accumulated
	// on this record
	ACCUMULATING_REDEMPTIONS UnbondingRecordStatus = 0
	// UNBONDING_QUEUE indicates the unbond amount for this epoch has been froze
	// and the tokens are ready to be unbonded on the host zone
	UNBONDING_QUEUE UnbondingRecordStatus = 1
	// UNBONDING_IN_PROGRESS indicates the unbonding is currently in progress on
	// the host zone
	UNBONDING_IN_PROGRESS UnbondingRecordStatus = 2
	// UNBONDED indicates the unbonding is finished on the host zone and the
	// tokens are still in the delegation account
	UNBONDED UnbondingRecordStatus = 3
	// CLAIMABLE indicates the unbonded tokens have been swept to stride and are
	// ready to be distributed to users
	CLAIMABLE UnbondingRecordStatus = 4
	// CLAIMED indicates the full unbonding cycle has been completed
	CLAIMED UnbondingRecordStatus = 5
)

var UnbondingRecordStatus_name = map[int32]string{
	0: "ACCUMULATING_REDEMPTIONS",
	1: "UNBONDING_QUEUE",
	2: "UNBONDING_IN_PROGRESS",
	3: "UNBONDED",
	4: "CLAIMABLE",
	5: "CLAIMED",
}

var UnbondingRecordStatus_value = map[string]int32{
	"ACCUMULATING_REDEMPTIONS": 0,
	"UNBONDING_QUEUE":          1,
	"UNBONDING_IN_PROGRESS":    2,
	"UNBONDED":                 3,
	"CLAIMABLE":                4,
	"CLAIMED":                  5,
}

func (x UnbondingRecordStatus) String() string {
	return proto.EnumName(UnbondingRecordStatus_name, int32(x))
}

func (UnbondingRecordStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{1}
}

type HostZone struct {
	// Chain ID
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Native token denom on the host zone (e.g. utia)
	NativeTokenDenom string `protobuf:"bytes,2,opt,name=native_token_denom,json=nativeTokenDenom,proto3" json:"native_token_denom,omitempty"`
	// IBC denom of the native token as it lives on stride (e.g. ibc/...)
	NativeTokenIbcDenom string `protobuf:"bytes,3,opt,name=native_token_ibc_denom,json=nativeTokenIbcDenom,proto3" json:"native_token_ibc_denom,omitempty"`
	// Transfer channel ID from stride to the host zone
	TransferChannelId string `protobuf:"bytes,4,opt,name=transfer_channel_id,json=transferChannelId,proto3" json:"transfer_channel_id,omitempty"`
	// Operator controlled delegation address on the host zone
	DelegationAddress string `protobuf:"bytes,5,opt,name=delegation_address,json=delegationAddress,proto3" json:"delegation_address,omitempty"`
	// Operator controlled reward address on the host zone
	RewardAddress string `protobuf:"bytes,6,opt,name=reward_address,json=rewardAddress,proto3" json:"reward_address,omitempty"`
	// Deposit address on stride
	DepositAddress string `protobuf:"bytes,7,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	// Redemption address on stride
	RedemptionAddress string `protobuf:"bytes,8,opt,name=redemption_address,json=redemptionAddress,proto3" json:"redemption_address,omitempty"`
	// Claim address on stride
	ClaimAddress string `protobuf:"bytes,9,opt,name=claim_address,json=claimAddress,proto3" json:"claim_address,omitempty"`
	// operator address set by safe, on stride
	OperatorAddressOnStride string `protobuf:"bytes,10,opt,name=operator_address_on_stride,json=operatorAddressOnStride,proto3" json:"operator_address_on_stride,omitempty"`
	// admin address set upon host zone creation,  on stride
	SafeAddressOnStride string `protobuf:"bytes,11,opt,name=safe_address_on_stride,json=safeAddressOnStride,proto3" json:"safe_address_on_stride,omitempty"`
	// Total delegated balance on the host zone delegation account
	RemainingDelegatedBalance cosmossdk_io_math.Int `protobuf:"bytes,18,opt,name=remaining_delegated_balance,json=remainingDelegatedBalance,proto3,customtype=cosmossdk.io/math.Int" json:"remaining_delegated_balance"`
	// The undelegation period for Celestia in days
	UnbondingPeriodSeconds uint64 `protobuf:"varint,19,opt,name=unbonding_period_seconds,json=unbondingPeriodSeconds,proto3" json:"unbonding_period_seconds,omitempty"`
	// Indicates whether the host zone has been halted
	Halted bool `protobuf:"varint,20,opt,name=halted,proto3" json:"halted,omitempty"`
}

func (m *HostZone) Reset()         { *m = HostZone{} }
func (m *HostZone) String() string { return proto.CompactTextString(m) }
func (*HostZone) ProtoMessage()    {}
func (*HostZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{0}
}
func (m *HostZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostZone.Merge(m, src)
}
func (m *HostZone) XXX_Size() int {
	return m.Size()
}
func (m *HostZone) XXX_DiscardUnknown() {
	xxx_messageInfo_HostZone.DiscardUnknown(m)
}

var xxx_messageInfo_HostZone proto.InternalMessageInfo

func (m *HostZone) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *HostZone) GetNativeTokenDenom() string {
	if m != nil {
		return m.NativeTokenDenom
	}
	return ""
}

func (m *HostZone) GetNativeTokenIbcDenom() string {
	if m != nil {
		return m.NativeTokenIbcDenom
	}
	return ""
}

func (m *HostZone) GetTransferChannelId() string {
	if m != nil {
		return m.TransferChannelId
	}
	return ""
}

func (m *HostZone) GetDelegationAddress() string {
	if m != nil {
		return m.DelegationAddress
	}
	return ""
}

func (m *HostZone) GetRewardAddress() string {
	if m != nil {
		return m.RewardAddress
	}
	return ""
}

func (m *HostZone) GetDepositAddress() string {
	if m != nil {
		return m.DepositAddress
	}
	return ""
}

func (m *HostZone) GetRedemptionAddress() string {
	if m != nil {
		return m.RedemptionAddress
	}
	return ""
}

func (m *HostZone) GetClaimAddress() string {
	if m != nil {
		return m.ClaimAddress
	}
	return ""
}

func (m *HostZone) GetOperatorAddressOnStride() string {
	if m != nil {
		return m.OperatorAddressOnStride
	}
	return ""
}

func (m *HostZone) GetSafeAddressOnStride() string {
	if m != nil {
		return m.SafeAddressOnStride
	}
	return ""
}

func (m *HostZone) GetUnbondingPeriodSeconds() uint64 {
	if m != nil {
		return m.UnbondingPeriodSeconds
	}
	return 0
}

func (m *HostZone) GetHalted() bool {
	if m != nil {
		return m.Halted
	}
	return false
}

// DelegationRecords track the aggregate liquid stakes and delegations
// for a given epoch
// Note: There is an important assumption here that tokens in the deposit
// account should not be tracked by these records. The record is created as soon
// as the tokens leave stride
type DelegationRecord struct {
	// Deposit record unique ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The amount of native tokens that should be delegated
	NativeAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=native_amount,json=nativeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"native_amount"`
	// The status indicating the point in the delegation's lifecycle
	Status DelegationRecordStatus `protobuf:"varint,3,opt,name=status,proto3,enum=stride.staketia.DelegationRecordStatus" json:"status,omitempty"`
	// The tx hash of the delegation on the host zone
	TxHash string `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
}

func (m *DelegationRecord) Reset()         { *m = DelegationRecord{} }
func (m *DelegationRecord) String() string { return proto.CompactTextString(m) }
func (*DelegationRecord) ProtoMessage()    {}
func (*DelegationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{1}
}
func (m *DelegationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationRecord.Merge(m, src)
}
func (m *DelegationRecord) XXX_Size() int {
	return m.Size()
}
func (m *DelegationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationRecord proto.InternalMessageInfo

func (m *DelegationRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DelegationRecord) GetStatus() DelegationRecordStatus {
	if m != nil {
		return m.Status
	}
	return TRANSFER_IN_PROGRESS
}

func (m *DelegationRecord) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// UnbondingRecords track the aggregate unbondings across an epoch
type UnbondingRecord struct {
	// Unbonding record ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The status indicating the point in the delegation's lifecycle
	Status UnbondingRecordStatus `protobuf:"varint,2,opt,name=status,proto3,enum=stride.staketia.UnbondingRecordStatus" json:"status,omitempty"`
	// The amount of stTokens that were redeemed
	StTokenAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=st_token_amount,json=stTokenAmount,proto3,customtype=cosmossdk.io/math.Int" json:"st_token_amount"`
	// The corresponding amount of native tokens that should be unbonded
	NativeAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=native_amount,json=nativeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"native_amount"`
	// The Unix timestamp (in seconds) at which the unbonding completes
	UnbondingCompletionTimeSeconds uint64 `protobuf:"varint,5,opt,name=unbonding_completion_time_seconds,json=unbondingCompletionTimeSeconds,proto3" json:"unbonding_completion_time_seconds,omitempty"`
	// The tx hash of the undelegation on the host zone
	UndelegationTxHash string `protobuf:"bytes,6,opt,name=undelegation_tx_hash,json=undelegationTxHash,proto3" json:"undelegation_tx_hash,omitempty"`
	// The tx hash of the unbonded token sweep on the host zone
	UnbondedTokenSweepTxHash string `protobuf:"bytes,7,opt,name=unbonded_token_sweep_tx_hash,json=unbondedTokenSweepTxHash,proto3" json:"unbonded_token_sweep_tx_hash,omitempty"`
}

func (m *UnbondingRecord) Reset()         { *m = UnbondingRecord{} }
func (m *UnbondingRecord) String() string { return proto.CompactTextString(m) }
func (*UnbondingRecord) ProtoMessage()    {}
func (*UnbondingRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{2}
}
func (m *UnbondingRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingRecord.Merge(m, src)
}
func (m *UnbondingRecord) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingRecord proto.InternalMessageInfo

func (m *UnbondingRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UnbondingRecord) GetStatus() UnbondingRecordStatus {
	if m != nil {
		return m.Status
	}
	return ACCUMULATING_REDEMPTIONS
}

func (m *UnbondingRecord) GetUnbondingCompletionTimeSeconds() uint64 {
	if m != nil {
		return m.UnbondingCompletionTimeSeconds
	}
	return 0
}

func (m *UnbondingRecord) GetUndelegationTxHash() string {
	if m != nil {
		return m.UndelegationTxHash
	}
	return ""
}

func (m *UnbondingRecord) GetUnbondedTokenSweepTxHash() string {
	if m != nil {
		return m.UnbondedTokenSweepTxHash
	}
	return ""
}

// RedemptionRecords track an individual user's redemption claims
type RedemptionRecord struct {
	// Unbonding record ID
	UnbondingRecordId uint64 `protobuf:"varint,1,opt,name=unbonding_record_id,json=unbondingRecordId,proto3" json:"unbonding_record_id,omitempty"`
	// Redeemer
	Redeemer string `protobuf:"bytes,2,opt,name=redeemer,proto3" json:"redeemer,omitempty"`
	// The amount of stTokens that were redeemed
	StTokenAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=st_token_amount,json=stTokenAmount,proto3,customtype=cosmossdk.io/math.Int" json:"st_token_amount"`
	// The corresponding amount of native tokens that should be unbonded
	NativeAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=native_amount,json=nativeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"native_amount"`
}

func (m *RedemptionRecord) Reset()         { *m = RedemptionRecord{} }
func (m *RedemptionRecord) String() string { return proto.CompactTextString(m) }
func (*RedemptionRecord) ProtoMessage()    {}
func (*RedemptionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{3}
}
func (m *RedemptionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedemptionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedemptionRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedemptionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedemptionRecord.Merge(m, src)
}
func (m *RedemptionRecord) XXX_Size() int {
	return m.Size()
}
func (m *RedemptionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_RedemptionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_RedemptionRecord proto.InternalMessageInfo

func (m *RedemptionRecord) GetUnbondingRecordId() uint64 {
	if m != nil {
		return m.UnbondingRecordId
	}
	return 0
}

func (m *RedemptionRecord) GetRedeemer() string {
	if m != nil {
		return m.Redeemer
	}
	return ""
}

// SlashRecords log adjustments to the delegated balance
type SlashRecord struct {
	// The slash record monotonically increasing ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The Unix timestamp (in seconds) when the slash adjustment was processed on
	// stride
	Time uint64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// The delta by which the total delegated amount changed from slash
	NativeAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=native_amount,json=nativeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"native_amount"`
	// The address (or addresses) of the validator that was slashed
	ValidatorAddress string `protobuf:"bytes,4,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
}

func (m *SlashRecord) Reset()         { *m = SlashRecord{} }
func (m *SlashRecord) String() string { return proto.CompactTextString(m) }
func (*SlashRecord) ProtoMessage()    {}
func (*SlashRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{4}
}
func (m *SlashRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashRecord.Merge(m, src)
}
func (m *SlashRecord) XXX_Size() int {
	return m.Size()
}
func (m *SlashRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SlashRecord proto.InternalMessageInfo

func (m *SlashRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SlashRecord) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SlashRecord) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("stride.staketia.DelegationRecordStatus", DelegationRecordStatus_name, DelegationRecordStatus_value)
	proto.RegisterEnum("stride.staketia.UnbondingRecordStatus", UnbondingRecordStatus_name, UnbondingRecordStatus_value)
	proto.RegisterType((*HostZone)(nil), "stride.staketia.HostZone")
	proto.RegisterType((*DelegationRecord)(nil), "stride.staketia.DelegationRecord")
	proto.RegisterType((*UnbondingRecord)(nil), "stride.staketia.UnbondingRecord")
	proto.RegisterType((*RedemptionRecord)(nil), "stride.staketia.RedemptionRecord")
	proto.RegisterType((*SlashRecord)(nil), "stride.staketia.SlashRecord")
}

func init() { proto.RegisterFile("stride/staketia/staketia.proto", fileDescriptor_d306d9365b78f7b2) }

var fileDescriptor_d306d9365b78f7b2 = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x16, 0x25, 0x45, 0x96, 0x8f, 0x2d, 0x9b, 0x1e, 0xc9, 0x36, 0xed, 0x3f, 0xbf, 0xe2, 0x7a,
	0xd1, 0x1a, 0x69, 0x23, 0x15, 0x0e, 0x50, 0x74, 0xd3, 0x04, 0xba, 0x30, 0x8e, 0x0a, 0x59, 0x76,
	0x29, 0x69, 0x13, 0xa0, 0x20, 0x46, 0x9c, 0x89, 0x44, 0x58, 0xe4, 0x08, 0x9c, 0x91, 0xe3, 0x02,
	0x7d, 0x80, 0x2e, 0xbb, 0xe9, 0x0b, 0xb4, 0xab, 0xee, 0xfb, 0x00, 0x5d, 0x66, 0x19, 0x74, 0x55,
	0x74, 0x11, 0x14, 0xf6, 0xaa, 0x7d, 0x8a, 0x82, 0x33, 0x24, 0x25, 0x5f, 0x02, 0x35, 0xbb, 0xee,
	0x38, 0xe7, 0x3b, 0xdf, 0x37, 0x73, 0xae, 0x20, 0x94, 0xb9, 0x08, 0x5c, 0x42, 0xab, 0x5c, 0xe0,
	0x33, 0x2a, 0x5c, 0x9c, 0x7c, 0x54, 0x26, 0x01, 0x13, 0x0c, 0xad, 0x2b, 0xbc, 0x12, 0x9b, 0x77,
	0x77, 0x1c, 0xc6, 0x3d, 0xc6, 0x6d, 0x09, 0x57, 0xd5, 0x41, 0xf9, 0xee, 0x96, 0x86, 0x6c, 0xc8,
	0x94, 0x3d, 0xfc, 0x52, 0xd6, 0xfd, 0xbf, 0x73, 0x90, 0x7f, 0xce, 0xb8, 0x78, 0xc1, 0x7c, 0x8a,
	0x76, 0x20, 0xef, 0x8c, 0xb0, 0xeb, 0xdb, 0x2e, 0x31, 0xb4, 0x3d, 0xed, 0x60, 0xd9, 0x5a, 0x92,
	0xe7, 0x16, 0x41, 0x9f, 0x00, 0xf2, 0xb1, 0x70, 0xcf, 0xa9, 0x2d, 0xd8, 0x19, 0xf5, 0x6d, 0x42,
	0x7d, 0xe6, 0x19, 0x69, 0xe9, 0xa4, 0x2b, 0xa4, 0x17, 0x02, 0xcd, 0xd0, 0x8e, 0x1e, 0xc3, 0xd6,
	0x35, 0x6f, 0x77, 0xe0, 0x44, 0x8c, 0x8c, 0x64, 0x14, 0xe7, 0x18, 0xad, 0x81, 0xa3, 0x48, 0x15,
	0x28, 0x8a, 0x00, 0xfb, 0xfc, 0x25, 0x0d, 0x6c, 0x67, 0x84, 0x7d, 0x9f, 0x8e, 0xc3, 0x87, 0x64,
	0x25, 0x63, 0x23, 0x86, 0x1a, 0x0a, 0x69, 0x11, 0x74, 0x04, 0x88, 0xd0, 0x31, 0x1d, 0x62, 0xe1,
	0x32, 0xdf, 0xc6, 0x84, 0x04, 0x94, 0x73, 0xe3, 0x5e, 0xe8, 0x5e, 0x37, 0x7e, 0xfb, 0xe5, 0x51,
	0x29, 0x0a, 0xbf, 0xa6, 0x90, 0xae, 0x08, 0x5c, 0x7f, 0x68, 0x6d, 0xcc, 0x38, 0x11, 0x80, 0x9e,
	0xc2, 0x5a, 0x40, 0x5f, 0xe1, 0x80, 0x24, 0x22, 0xb9, 0x05, 0x22, 0x05, 0xe5, 0x1f, 0x0b, 0xd4,
	0x60, 0x9d, 0xd0, 0x09, 0xe3, 0xae, 0x48, 0x14, 0x96, 0x16, 0x28, 0xac, 0x45, 0x84, 0x58, 0xe2,
	0x08, 0x50, 0x40, 0x09, 0xf5, 0x26, 0xd7, 0x82, 0xc9, 0x2f, 0x0a, 0x66, 0xc6, 0x89, 0x85, 0xbe,
	0x80, 0x82, 0x33, 0xc6, 0xae, 0x97, 0x68, 0x2c, 0x2f, 0xd0, 0x58, 0x95, 0xee, 0x31, 0xbd, 0x0f,
	0xbb, 0x6c, 0x42, 0x03, 0x2c, 0x58, 0x10, 0x2b, 0xd8, 0xcc, 0xb7, 0x55, 0x9f, 0x19, 0xb0, 0x40,
	0x6b, 0x3b, 0xe6, 0x46, 0xe6, 0x13, 0xbf, 0x2b, 0x89, 0xe8, 0x18, 0xb6, 0x38, 0x7e, 0x49, 0xef,
	0x90, 0x5c, 0x59, 0x20, 0x59, 0x0c, 0x79, 0x37, 0xe5, 0xbe, 0x86, 0xff, 0x05, 0xd4, 0xc3, 0xae,
	0xef, 0xfa, 0x43, 0x3b, 0x2a, 0x28, 0x25, 0xf6, 0x00, 0x8f, 0xb1, 0xef, 0x50, 0x03, 0x49, 0xcd,
	0xff, 0xbf, 0x7e, 0xfb, 0x20, 0xf5, 0xc7, 0xdb, 0x07, 0x9b, 0x4a, 0x97, 0x93, 0xb3, 0x8a, 0xcb,
	0xaa, 0x1e, 0x16, 0xa3, 0x4a, 0xcb, 0x17, 0xd6, 0x4e, 0xa2, 0xd0, 0x8c, 0x05, 0xea, 0x8a, 0x8f,
	0x3e, 0x07, 0x63, 0xea, 0x0f, 0x98, 0x4f, 0x42, 0xf9, 0x09, 0x0d, 0x5c, 0x46, 0x6c, 0x4e, 0x1d,
	0xe6, 0x13, 0x6e, 0x14, 0xf7, 0xb4, 0x83, 0xac, 0xb5, 0x95, 0xe0, 0xa7, 0x12, 0xee, 0x2a, 0x14,
	0x6d, 0x41, 0x6e, 0x84, 0xc7, 0x82, 0x12, 0xa3, 0xb4, 0xa7, 0x1d, 0xe4, 0xad, 0xe8, 0xf4, 0x65,
	0x36, 0x5f, 0xd0, 0xd7, 0xf6, 0x7f, 0xd5, 0x40, 0x6f, 0x26, 0xed, 0x67, 0x51, 0x87, 0x05, 0x04,
	0xad, 0x41, 0x3a, 0x1a, 0xb7, 0xac, 0x95, 0x76, 0x09, 0xaa, 0x43, 0x21, 0x9a, 0x1d, 0xec, 0xb1,
	0xa9, 0x2f, 0xd4, 0x90, 0x2d, 0x8a, 0x66, 0x55, 0x71, 0x6a, 0x92, 0x82, 0x9e, 0x42, 0x8e, 0x0b,
	0x2c, 0xa6, 0x5c, 0xce, 0xdb, 0xda, 0xe1, 0x47, 0x95, 0x1b, 0x8b, 0xa2, 0x72, 0xf3, 0x19, 0x5d,
	0xe9, 0x6e, 0x45, 0x34, 0xb4, 0x0d, 0x4b, 0xe2, 0xc2, 0x1e, 0x61, 0x3e, 0x8a, 0xe6, 0x2f, 0x27,
	0x2e, 0x9e, 0x63, 0x3e, 0xda, 0xff, 0x39, 0x03, 0xeb, 0xfd, 0x38, 0xf6, 0x77, 0x44, 0xf0, 0x24,
	0xb9, 0x3d, 0x2d, 0x6f, 0xff, 0xf0, 0xd6, 0xed, 0x37, 0x14, 0x6e, 0x5c, 0x6e, 0xc2, 0x3a, 0x17,
	0xd1, 0xe6, 0x88, 0x72, 0x90, 0xf9, 0x37, 0x39, 0x28, 0x70, 0x21, 0x37, 0x4a, 0x94, 0x84, 0x5b,
	0x89, 0xcc, 0xbe, 0x7f, 0x22, 0x5b, 0xf0, 0xc1, 0xac, 0x13, 0x1c, 0xe6, 0x4d, 0xc6, 0x54, 0x0e,
	0xa8, 0x70, 0x3d, 0x9a, 0xb4, 0xc4, 0x3d, 0x19, 0x79, 0x39, 0x71, 0x6c, 0x24, 0x7e, 0x3d, 0xd7,
	0xa3, 0x71, 0x6b, 0x7c, 0x0a, 0xa5, 0xa9, 0x3f, 0xb7, 0xb0, 0xe2, 0xfc, 0xca, 0x5d, 0x63, 0xa1,
	0x79, 0xac, 0x27, 0x73, 0x8d, 0x9e, 0xc0, 0x7d, 0xa5, 0x49, 0x49, 0x94, 0x0d, 0xfe, 0x8a, 0xd2,
	0x49, 0xc2, 0x94, 0x3b, 0xc6, 0x32, 0x62, 0x1f, 0x19, 0x7b, 0x37, 0xf4, 0x50, 0xfc, 0xfd, 0xbf,
	0x34, 0xd0, 0xad, 0x64, 0x41, 0x44, 0xc5, 0xaa, 0x40, 0x71, 0x16, 0x51, 0x20, 0x6d, 0x76, 0x52,
	0xbd, 0x8d, 0xe9, 0xf5, 0xc2, 0xb4, 0x08, 0xda, 0x85, 0x7c, 0xb8, 0x64, 0xa8, 0x47, 0x83, 0x68,
	0xdd, 0x27, 0xe7, 0xff, 0x50, 0xa1, 0xf6, 0x7f, 0xd4, 0x60, 0xa5, 0x3b, 0xc6, 0x7c, 0xf4, 0x8e,
	0x9e, 0x44, 0x90, 0x0d, 0x6b, 0x26, 0x43, 0xc8, 0x5a, 0xf2, 0xfb, 0xf6, 0xbd, 0x99, 0xf7, 0x6f,
	0x90, 0x8f, 0x61, 0xe3, 0x1c, 0x8f, 0x5d, 0x32, 0xbf, 0x30, 0xa3, 0x91, 0xd1, 0x13, 0x20, 0x5a,
	0x5f, 0x0f, 0xbf, 0x85, 0xad, 0xbb, 0xe7, 0x0e, 0x19, 0x50, 0xea, 0x59, 0xb5, 0x4e, 0xf7, 0x99,
	0x69, 0xd9, 0xad, 0x8e, 0x7d, 0x6a, 0x9d, 0x1c, 0x59, 0x66, 0xb7, 0xab, 0xa7, 0x50, 0x11, 0xd6,
	0x13, 0xe4, 0x59, 0xad, 0xd5, 0x36, 0x9b, 0xba, 0x86, 0x4a, 0xa0, 0x37, 0xcd, 0xb6, 0x79, 0x54,
	0xeb, 0xb5, 0x4e, 0x3a, 0xf6, 0x57, 0x7d, 0xb3, 0x6f, 0xea, 0x69, 0xb4, 0x0d, 0xc5, 0x39, 0x6b,
	0xe3, 0xe4, 0xf8, 0xb4, 0x6d, 0xf6, 0x4c, 0x3d, 0xb3, 0x9b, 0xfd, 0xee, 0xa7, 0x72, 0xea, 0xe1,
	0x0f, 0x1a, 0x6c, 0xde, 0x39, 0x78, 0xe8, 0x3e, 0x18, 0xb5, 0x46, 0xa3, 0x7f, 0xdc, 0x6f, 0xd7,
	0x7a, 0xad, 0xce, 0x91, 0x6d, 0x99, 0x4d, 0xf3, 0xf8, 0x34, 0x54, 0x89, 0x5e, 0xd0, 0xef, 0xd4,
	0x4f, 0x3a, 0xcd, 0x10, 0x52, 0x77, 0x69, 0x68, 0x07, 0x36, 0x67, 0xc6, 0xf9, 0x17, 0xa7, 0xd1,
	0x2a, 0xe4, 0x15, 0x64, 0x36, 0xf5, 0x0c, 0x2a, 0xc0, 0x72, 0xa3, 0x5d, 0x6b, 0x1d, 0xd7, 0xea,
	0x6d, 0x53, 0xcf, 0xa2, 0x15, 0x58, 0x92, 0x47, 0xb3, 0xa9, 0xdf, 0x53, 0xef, 0xaa, 0xb7, 0x5f,
	0x5f, 0x96, 0xb5, 0x37, 0x97, 0x65, 0xed, 0xcf, 0xcb, 0xb2, 0xf6, 0xfd, 0x55, 0x39, 0xf5, 0xe6,
	0xaa, 0x9c, 0xfa, 0xfd, 0xaa, 0x9c, 0x7a, 0x71, 0x38, 0x74, 0xc5, 0x68, 0x3a, 0xa8, 0x38, 0xcc,
	0xab, 0xaa, 0xcd, 0xff, 0xa8, 0x8d, 0x07, 0xbc, 0x1a, 0xfd, 0x15, 0x9d, 0x1f, 0x7e, 0x56, 0xbd,
	0x98, 0xfd, 0x1b, 0x89, 0x6f, 0x26, 0x94, 0x0f, 0x72, 0xf2, 0xbf, 0xe6, 0xf1, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x95, 0xce, 0x4a, 0x0f, 0x3b, 0x09, 0x00, 0x00,
}

func (m *HostZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostZone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostZone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Halted {
		i--
		if m.Halted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.UnbondingPeriodSeconds != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.UnbondingPeriodSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	{
		size := m.RemainingDelegatedBalance.Size()
		i -= size
		if _, err := m.RemainingDelegatedBalance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	if len(m.SafeAddressOnStride) > 0 {
		i -= len(m.SafeAddressOnStride)
		copy(dAtA[i:], m.SafeAddressOnStride)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.SafeAddressOnStride)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.OperatorAddressOnStride) > 0 {
		i -= len(m.OperatorAddressOnStride)
		copy(dAtA[i:], m.OperatorAddressOnStride)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.OperatorAddressOnStride)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClaimAddress) > 0 {
		i -= len(m.ClaimAddress)
		copy(dAtA[i:], m.ClaimAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ClaimAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RedemptionAddress) > 0 {
		i -= len(m.RedemptionAddress)
		copy(dAtA[i:], m.RedemptionAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.RedemptionAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DepositAddress) > 0 {
		i -= len(m.DepositAddress)
		copy(dAtA[i:], m.DepositAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.DepositAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RewardAddress) > 0 {
		i -= len(m.RewardAddress)
		copy(dAtA[i:], m.RewardAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.RewardAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DelegationAddress) > 0 {
		i -= len(m.DelegationAddress)
		copy(dAtA[i:], m.DelegationAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.DelegationAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TransferChannelId) > 0 {
		i -= len(m.TransferChannelId)
		copy(dAtA[i:], m.TransferChannelId)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.TransferChannelId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NativeTokenIbcDenom) > 0 {
		i -= len(m.NativeTokenIbcDenom)
		copy(dAtA[i:], m.NativeTokenIbcDenom)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.NativeTokenIbcDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NativeTokenDenom) > 0 {
		i -= len(m.NativeTokenDenom)
		copy(dAtA[i:], m.NativeTokenDenom)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.NativeTokenDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnbondedTokenSweepTxHash) > 0 {
		i -= len(m.UnbondedTokenSweepTxHash)
		copy(dAtA[i:], m.UnbondedTokenSweepTxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.UnbondedTokenSweepTxHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UndelegationTxHash) > 0 {
		i -= len(m.UndelegationTxHash)
		copy(dAtA[i:], m.UndelegationTxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.UndelegationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnbondingCompletionTimeSeconds != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.UnbondingCompletionTimeSeconds))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.StTokenAmount.Size()
		i -= size
		if _, err := m.StTokenAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedemptionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedemptionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedemptionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.StTokenAmount.Size()
		i -= size
		if _, err := m.StTokenAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Redeemer) > 0 {
		i -= len(m.Redeemer)
		copy(dAtA[i:], m.Redeemer)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.Redeemer)))
		i--
		dAtA[i] = 0x12
	}
	if m.UnbondingRecordId != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.UnbondingRecordId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlashRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Time != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStaketia(dAtA []byte, offset int, v uint64) int {
	offset -= sovStaketia(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HostZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.NativeTokenDenom)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.NativeTokenIbcDenom)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.TransferChannelId)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.DelegationAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.RewardAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.DepositAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.RedemptionAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.ClaimAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.OperatorAddressOnStride)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.SafeAddressOnStride)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = m.RemainingDelegatedBalance.Size()
	n += 2 + l + sovStaketia(uint64(l))
	if m.UnbondingPeriodSeconds != 0 {
		n += 2 + sovStaketia(uint64(m.UnbondingPeriodSeconds))
	}
	if m.Halted {
		n += 3
	}
	return n
}

func (m *DelegationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	if m.Status != 0 {
		n += 1 + sovStaketia(uint64(m.Status))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func (m *UnbondingRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	if m.Status != 0 {
		n += 1 + sovStaketia(uint64(m.Status))
	}
	l = m.StTokenAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	if m.UnbondingCompletionTimeSeconds != 0 {
		n += 1 + sovStaketia(uint64(m.UnbondingCompletionTimeSeconds))
	}
	l = len(m.UndelegationTxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.UnbondedTokenSweepTxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func (m *RedemptionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnbondingRecordId != 0 {
		n += 1 + sovStaketia(uint64(m.UnbondingRecordId))
	}
	l = len(m.Redeemer)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = m.StTokenAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	return n
}

func (m *SlashRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	if m.Time != 0 {
		n += 1 + sovStaketia(uint64(m.Time))
	}
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func sovStaketia(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStaketia(x uint64) (n int) {
	return sovStaketia(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HostZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeTokenDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeTokenDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeTokenIbcDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeTokenIbcDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedemptionAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddressOnStride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddressOnStride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeAddressOnStride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SafeAddressOnStride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingDelegatedBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingDelegatedBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingPeriodSeconds", wireType)
			}
			m.UnbondingPeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingPeriodSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Halted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Halted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DelegationRecordStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UnbondingRecordStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StTokenAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingCompletionTimeSeconds", wireType)
			}
			m.UnbondingCompletionTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingCompletionTimeSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UndelegationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedTokenSweepTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondedTokenSweepTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedemptionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedemptionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedemptionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingRecordId", wireType)
			}
			m.UnbondingRecordId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingRecordId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redeemer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redeemer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StTokenAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStaketia(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStaketia
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStaketia
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStaketia
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStaketia        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStaketia          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStaketia = fmt.Errorf("proto: unexpected end of group")
)
