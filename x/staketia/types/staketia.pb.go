// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stride/staketia/staketia.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status fields for a delegation record
type DelegationRecordStatus int32

const (
	// TRANSFER_IN_PROGRESS indicates the native tokens are being sent from the
	// deposit account to the delegation account
	TRANSFER_IN_PROGRESS DelegationRecordStatus = 0
	// DELEGATION_QUEUE indicates the tokens have landed on the host zone and are
	// ready to be delegated
	DELEGATION_QUEUE DelegationRecordStatus = 1
	// ARCHIVE indicates the delegation has been completed
	DELEGATION_ARCHIVE DelegationRecordStatus = 2
)

var DelegationRecordStatus_name = map[int32]string{
	0: "TRANSFER_IN_PROGRESS",
	1: "DELEGATION_QUEUE",
	2: "DELEGATION_ARCHIVE",
}

var DelegationRecordStatus_value = map[string]int32{
	"TRANSFER_IN_PROGRESS": 0,
	"DELEGATION_QUEUE":     1,
	"DELEGATION_ARCHIVE":   2,
}

func (x DelegationRecordStatus) String() string {
	return proto.EnumName(DelegationRecordStatus_name, int32(x))
}

func (DelegationRecordStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{0}
}

// Status fields for an unbonding record
type UnbondingRecordStatus int32

const (
	// TALLY_REDEMPTIONS indicates redemptions are still being accumulated on this
	// record
	TALLYING_REDEMPTIONS UnbondingRecordStatus = 0
	// UNBONDING_QUEUE indicates the unbond amount for this epoch has been froze
	// and the tokens are ready to be unbonded on the host zone
	UNBONDING_QUEUE UnbondingRecordStatus = 1
	// UNBONDING_IN_PROGRESS indicates the unbonding is currently in progress on
	// the host zone
	UNBONDING_IN_PROGRESS UnbondingRecordStatus = 2
	// UNBONDED indicates the unbonding is finished on the host zone and the
	// tokens are still in the delegation account
	UNBONDED UnbondingRecordStatus = 3
	// CLAIMABLE indicates the unbonded tokens have been swept to stride and are
	// ready to be distributed to users
	CLAIMABLE UnbondingRecordStatus = 4
	// ARCHIVE indicates the full unbonding cycle has been completed
	ARCHIVE UnbondingRecordStatus = 5
)

var UnbondingRecordStatus_name = map[int32]string{
	0: "TALLYING_REDEMPTIONS",
	1: "UNBONDING_QUEUE",
	2: "UNBONDING_IN_PROGRESS",
	3: "UNBONDED",
	4: "CLAIMABLE",
	5: "ARCHIVE",
}

var UnbondingRecordStatus_value = map[string]int32{
	"TALLYING_REDEMPTIONS":  0,
	"UNBONDING_QUEUE":       1,
	"UNBONDING_IN_PROGRESS": 2,
	"UNBONDED":              3,
	"CLAIMABLE":             4,
	"ARCHIVE":               5,
}

func (x UnbondingRecordStatus) String() string {
	return proto.EnumName(UnbondingRecordStatus_name, int32(x))
}

func (UnbondingRecordStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{1}
}

type HostZone struct {
	// Chain ID
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Native token denom on the host zone
	NativeDenom string `protobuf:"bytes,2,opt,name=native_denom,json=nativeDenom,proto3" json:"native_denom,omitempty"`
	// Transfer channel ID from stride to the host zone
	TransferChannelId string `protobuf:"bytes,3,opt,name=transfer_channel_id,json=transferChannelId,proto3" json:"transfer_channel_id,omitempty"`
	// Operator controlled delegation address on the host zone
	DelegationAddress string `protobuf:"bytes,4,opt,name=delegation_address,json=delegationAddress,proto3" json:"delegation_address,omitempty"`
	// Operator controlled reward address on the host zone
	RewardAddress string `protobuf:"bytes,5,opt,name=reward_address,json=rewardAddress,proto3" json:"reward_address,omitempty"`
	// Deposit module address on stride
	DepositAddress string `protobuf:"bytes,6,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	// Redemption module address on stride
	RedemptionAddress string `protobuf:"bytes,7,opt,name=redemption_address,json=redemptionAddress,proto3" json:"redemption_address,omitempty"`
	// Claim module address on stride
	ClaimAddress string `protobuf:"bytes,8,opt,name=claim_address,json=claimAddress,proto3" json:"claim_address,omitempty"`
	// Previous redemption rate
	LastRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=last_redemption_rate,json=lastRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"last_redemption_rate"`
	// Current redemption rate
	RedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=redemption_rate,json=redemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"redemption_rate"`
	// Min outer redemption rate - adjusted by governance
	MinRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=min_redemption_rate,json=minRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_redemption_rate"`
	// Max outer redemption rate - adjusted by governance
	MaxRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=max_redemption_rate,json=maxRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_redemption_rate"`
	// Min inner redemption rate - adjusted by controller
	MinInnerRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=min_inner_redemption_rate,json=minInnerRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_inner_redemption_rate"`
	// Max inner redemption rate - adjusted by controller
	MaxInnerRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=max_inner_redemption_rate,json=maxInnerRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_inner_redemption_rate"`
	// Total delegated balance on the host zone delegation account
	DelegatedBalance github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,15,opt,name=delegated_balance,json=delegatedBalance,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"delegated_balance"`
	// Indicates whether the host zone has been halted
	Halted bool `protobuf:"varint,16,opt,name=halted,proto3" json:"halted,omitempty"`
}

func (m *HostZone) Reset()         { *m = HostZone{} }
func (m *HostZone) String() string { return proto.CompactTextString(m) }
func (*HostZone) ProtoMessage()    {}
func (*HostZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{0}
}
func (m *HostZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostZone.Merge(m, src)
}
func (m *HostZone) XXX_Size() int {
	return m.Size()
}
func (m *HostZone) XXX_DiscardUnknown() {
	xxx_messageInfo_HostZone.DiscardUnknown(m)
}

var xxx_messageInfo_HostZone proto.InternalMessageInfo

func (m *HostZone) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *HostZone) GetNativeDenom() string {
	if m != nil {
		return m.NativeDenom
	}
	return ""
}

func (m *HostZone) GetTransferChannelId() string {
	if m != nil {
		return m.TransferChannelId
	}
	return ""
}

func (m *HostZone) GetDelegationAddress() string {
	if m != nil {
		return m.DelegationAddress
	}
	return ""
}

func (m *HostZone) GetRewardAddress() string {
	if m != nil {
		return m.RewardAddress
	}
	return ""
}

func (m *HostZone) GetDepositAddress() string {
	if m != nil {
		return m.DepositAddress
	}
	return ""
}

func (m *HostZone) GetRedemptionAddress() string {
	if m != nil {
		return m.RedemptionAddress
	}
	return ""
}

func (m *HostZone) GetClaimAddress() string {
	if m != nil {
		return m.ClaimAddress
	}
	return ""
}

func (m *HostZone) GetHalted() bool {
	if m != nil {
		return m.Halted
	}
	return false
}

// DelegationRecords track the aggregate liquid stakes and delegations
// for a given epoch
type DelegationRecord struct {
	// Deposit record unique ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The amount of native tokens that should be delegated
	NativeAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=native_amount,json=nativeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"native_amount"`
	// The status indicating the point in the delegation's lifecycle
	Status DelegationRecordStatus `protobuf:"varint,3,opt,name=status,proto3,enum=stride.staketia.DelegationRecordStatus" json:"status,omitempty"`
	// The tx hash of the delegation on the host zone
	TxHash string `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
}

func (m *DelegationRecord) Reset()         { *m = DelegationRecord{} }
func (m *DelegationRecord) String() string { return proto.CompactTextString(m) }
func (*DelegationRecord) ProtoMessage()    {}
func (*DelegationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{1}
}
func (m *DelegationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationRecord.Merge(m, src)
}
func (m *DelegationRecord) XXX_Size() int {
	return m.Size()
}
func (m *DelegationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationRecord proto.InternalMessageInfo

func (m *DelegationRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DelegationRecord) GetStatus() DelegationRecordStatus {
	if m != nil {
		return m.Status
	}
	return TRANSFER_IN_PROGRESS
}

func (m *DelegationRecord) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// UnbondingRecords track the aggregate unbondings across an epoch
type UnbondingRecord struct {
	// Unbonding record ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The status indicating the point in the delegation's lifecycle
	Status UnbondingRecordStatus `protobuf:"varint,2,opt,name=status,proto3,enum=stride.staketia.UnbondingRecordStatus" json:"status,omitempty"`
	// The amount of stTokens that were redeemed
	StTokenAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=st_token_amount,json=stTokenAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"st_token_amount"`
	// The corresponding amount of native tokens that should be unbonded
	NativeAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=native_amount,json=nativeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"native_amount"`
	// The time at which the unbonding completes
	UnbondingCompletionTime time.Time `protobuf:"bytes,5,opt,name=unbonding_completion_time,json=unbondingCompletionTime,proto3,stdtime" json:"unbonding_completion_time"`
	// The tx hash of the undelegation on the host zone
	UndelegationTxHash string `protobuf:"bytes,6,opt,name=undelegation_tx_hash,json=undelegationTxHash,proto3" json:"undelegation_tx_hash,omitempty"`
	// The tx hash of the unbonded token sweep on the host zone
	UnbondedTokenSweepTxHash string `protobuf:"bytes,7,opt,name=unbonded_token_sweep_tx_hash,json=unbondedTokenSweepTxHash,proto3" json:"unbonded_token_sweep_tx_hash,omitempty"`
}

func (m *UnbondingRecord) Reset()         { *m = UnbondingRecord{} }
func (m *UnbondingRecord) String() string { return proto.CompactTextString(m) }
func (*UnbondingRecord) ProtoMessage()    {}
func (*UnbondingRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{2}
}
func (m *UnbondingRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingRecord.Merge(m, src)
}
func (m *UnbondingRecord) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingRecord proto.InternalMessageInfo

func (m *UnbondingRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UnbondingRecord) GetStatus() UnbondingRecordStatus {
	if m != nil {
		return m.Status
	}
	return TALLYING_REDEMPTIONS
}

func (m *UnbondingRecord) GetUnbondingCompletionTime() time.Time {
	if m != nil {
		return m.UnbondingCompletionTime
	}
	return time.Time{}
}

func (m *UnbondingRecord) GetUndelegationTxHash() string {
	if m != nil {
		return m.UndelegationTxHash
	}
	return ""
}

func (m *UnbondingRecord) GetUnbondedTokenSweepTxHash() string {
	if m != nil {
		return m.UnbondedTokenSweepTxHash
	}
	return ""
}

// RedemptionRecords track an individual user's redemption claims
type RedemptionRecord struct {
	// Redemption record ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Redeemer
	Redeemer string `protobuf:"bytes,2,opt,name=redeemer,proto3" json:"redeemer,omitempty"`
	// The amount of stTokens that were redeemed
	StTokenAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=st_token_amount,json=stTokenAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"st_token_amount"`
	// The corresponding amount of native tokens that should be unbonded
	NativeAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=native_amount,json=nativeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"native_amount"`
}

func (m *RedemptionRecord) Reset()         { *m = RedemptionRecord{} }
func (m *RedemptionRecord) String() string { return proto.CompactTextString(m) }
func (*RedemptionRecord) ProtoMessage()    {}
func (*RedemptionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{3}
}
func (m *RedemptionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedemptionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedemptionRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedemptionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedemptionRecord.Merge(m, src)
}
func (m *RedemptionRecord) XXX_Size() int {
	return m.Size()
}
func (m *RedemptionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_RedemptionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_RedemptionRecord proto.InternalMessageInfo

func (m *RedemptionRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RedemptionRecord) GetRedeemer() string {
	if m != nil {
		return m.Redeemer
	}
	return ""
}

// SlashRecords log adjustments to the delegated balance
type SlashRecord struct {
	// The slash record monotonically increasing ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The block time at which the slash adjustment was processed on stride
	Time time.Time `protobuf:"bytes,2,opt,name=time,proto3,stdtime" json:"time"`
	// The address (or addresses) of the validator that was slashed
	ValidatorAddress string `protobuf:"bytes,3,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
}

func (m *SlashRecord) Reset()         { *m = SlashRecord{} }
func (m *SlashRecord) String() string { return proto.CompactTextString(m) }
func (*SlashRecord) ProtoMessage()    {}
func (*SlashRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d306d9365b78f7b2, []int{4}
}
func (m *SlashRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashRecord.Merge(m, src)
}
func (m *SlashRecord) XXX_Size() int {
	return m.Size()
}
func (m *SlashRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SlashRecord proto.InternalMessageInfo

func (m *SlashRecord) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SlashRecord) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

func (m *SlashRecord) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("stride.staketia.DelegationRecordStatus", DelegationRecordStatus_name, DelegationRecordStatus_value)
	proto.RegisterEnum("stride.staketia.UnbondingRecordStatus", UnbondingRecordStatus_name, UnbondingRecordStatus_value)
	proto.RegisterType((*HostZone)(nil), "stride.staketia.HostZone")
	proto.RegisterType((*DelegationRecord)(nil), "stride.staketia.DelegationRecord")
	proto.RegisterType((*UnbondingRecord)(nil), "stride.staketia.UnbondingRecord")
	proto.RegisterType((*RedemptionRecord)(nil), "stride.staketia.RedemptionRecord")
	proto.RegisterType((*SlashRecord)(nil), "stride.staketia.SlashRecord")
}

func init() { proto.RegisterFile("stride/staketia/staketia.proto", fileDescriptor_d306d9365b78f7b2) }

var fileDescriptor_d306d9365b78f7b2 = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4d, 0x6f, 0x1a, 0xc7,
	0x1b, 0x67, 0x31, 0xb1, 0xf1, 0x63, 0x03, 0xeb, 0x31, 0x71, 0xb0, 0xf5, 0x17, 0xce, 0xdf, 0x87,
	0x34, 0x4a, 0xe5, 0xa5, 0x75, 0x0f, 0xed, 0xa1, 0x4d, 0x04, 0x66, 0x6b, 0x23, 0x11, 0x9c, 0x0e,
	0x76, 0xa4, 0xa6, 0x87, 0xed, 0xc0, 0x8e, 0x61, 0xe5, 0xdd, 0x19, 0xb4, 0x33, 0xd8, 0xf4, 0xde,
	0x43, 0x8f, 0xe9, 0x67, 0xe8, 0x57, 0xc8, 0x87, 0xc8, 0x31, 0xcd, 0xa9, 0xea, 0x21, 0xad, 0xec,
	0x43, 0x0f, 0xfd, 0x12, 0xd5, 0xce, 0xbe, 0x98, 0x00, 0x91, 0xe5, 0x8a, 0x4b, 0x4f, 0x30, 0xcf,
	0xcb, 0xef, 0xf7, 0xbc, 0xec, 0x3c, 0xcf, 0x40, 0x59, 0x48, 0xdf, 0xb1, 0x69, 0x45, 0x48, 0x72,
	0x46, 0xa5, 0x43, 0x92, 0x3f, 0xc6, 0xc0, 0xe7, 0x92, 0xa3, 0x42, 0xa8, 0x37, 0x62, 0xf1, 0xd6,
	0x66, 0x97, 0x0b, 0x8f, 0x0b, 0x4b, 0xa9, 0x2b, 0xe1, 0x21, 0xb4, 0xdd, 0x2a, 0xf6, 0x78, 0x8f,
	0x87, 0xf2, 0xe0, 0x5f, 0x24, 0xdd, 0xee, 0x71, 0xde, 0x73, 0x69, 0x45, 0x9d, 0x3a, 0xc3, 0xd3,
	0x8a, 0x74, 0x3c, 0x2a, 0x24, 0xf1, 0x06, 0xa1, 0xc1, 0xce, 0x5f, 0xcb, 0x90, 0x3d, 0xe4, 0x42,
	0xbe, 0xe0, 0x8c, 0xa2, 0x4d, 0xc8, 0x76, 0xfb, 0xc4, 0x61, 0x96, 0x63, 0x97, 0xb4, 0xfb, 0xda,
	0xc3, 0x65, 0xbc, 0xa4, 0xce, 0x0d, 0x1b, 0xfd, 0x1f, 0x56, 0x19, 0x91, 0xce, 0x39, 0xb5, 0x6c,
	0xca, 0xb8, 0x57, 0x4a, 0x2b, 0xf5, 0x4a, 0x28, 0xab, 0x07, 0x22, 0x64, 0xc0, 0xba, 0xf4, 0x09,
	0x13, 0xa7, 0xd4, 0xb7, 0xba, 0x7d, 0xc2, 0x18, 0x75, 0x03, 0xa0, 0x05, 0x65, 0xb9, 0x16, 0xab,
	0xf6, 0x43, 0x4d, 0xc3, 0x46, 0x07, 0x80, 0x6c, 0xea, 0xd2, 0x1e, 0x91, 0x0e, 0x67, 0x16, 0xb1,
	0x6d, 0x9f, 0x0a, 0x51, 0xca, 0x04, 0xe6, 0xb5, 0xd2, 0xdb, 0x57, 0xbb, 0xc5, 0x28, 0xbf, 0x6a,
	0xa8, 0x69, 0x4b, 0xdf, 0x61, 0x3d, 0xbc, 0x76, 0xed, 0x13, 0x29, 0xd0, 0x13, 0xc8, 0xfb, 0xf4,
	0x82, 0xf8, 0x76, 0x02, 0x72, 0xe7, 0x06, 0x90, 0x5c, 0x68, 0x1f, 0x03, 0x54, 0xa1, 0x60, 0xd3,
	0x01, 0x17, 0x8e, 0x4c, 0x10, 0x16, 0x6f, 0x40, 0xc8, 0x47, 0x0e, 0x31, 0xc4, 0x01, 0x20, 0x9f,
	0xda, 0xd4, 0x1b, 0xbc, 0x97, 0xcc, 0xd2, 0x4d, 0xc9, 0x5c, 0xfb, 0xc4, 0x40, 0x5f, 0x41, 0xae,
	0xeb, 0x12, 0xc7, 0x4b, 0x30, 0xb2, 0x37, 0x60, 0xac, 0x2a, 0xf3, 0xd8, 0x9d, 0x41, 0xd1, 0x25,
	0x42, 0x5a, 0x63, 0xc1, 0xf8, 0x44, 0xd2, 0xd2, 0xb2, 0x42, 0xf9, 0xf2, 0xf5, 0xbb, 0xed, 0xd4,
	0xef, 0xef, 0xb6, 0x1f, 0xf4, 0x1c, 0xd9, 0x1f, 0x76, 0x8c, 0x2e, 0xf7, 0xa2, 0xaf, 0x28, 0xfa,
	0xd9, 0x15, 0xf6, 0x59, 0x45, 0xfe, 0x30, 0xa0, 0xc2, 0xa8, 0xd3, 0xee, 0xdb, 0x57, 0xbb, 0x10,
	0x71, 0xd6, 0x69, 0x17, 0xa3, 0x00, 0x19, 0x27, 0xc0, 0x98, 0x48, 0x8a, 0x28, 0x14, 0x26, 0xa9,
	0x60, 0x0e, 0x54, 0x79, 0xff, 0x7d, 0x1a, 0x17, 0xd6, 0x3d, 0x87, 0x4d, 0x65, 0xb5, 0x32, 0x07,
	0xaa, 0x35, 0xcf, 0x61, 0x78, 0x9a, 0x8d, 0x8c, 0xa6, 0xd8, 0x56, 0xe7, 0xc2, 0x46, 0x46, 0x13,
	0x6c, 0x17, 0xb0, 0x19, 0xe4, 0xe6, 0x30, 0x46, 0xfd, 0x29, 0xce, 0xdc, 0x1c, 0x38, 0x37, 0x3c,
	0x87, 0x35, 0x02, 0xf4, 0x19, 0xc4, 0x64, 0xf4, 0x01, 0xe2, 0xfc, 0x5c, 0x88, 0xc9, 0x68, 0x16,
	0xf1, 0x77, 0x10, 0xdf, 0x62, 0x6a, 0x5b, 0x1d, 0xe2, 0x12, 0xd6, 0xa5, 0xa5, 0x82, 0x22, 0x34,
	0x6e, 0x41, 0xd8, 0x60, 0x12, 0xeb, 0x09, 0x50, 0x2d, 0xc4, 0x41, 0x1b, 0xb0, 0xd8, 0x27, 0xae,
	0xa4, 0x76, 0x49, 0xbf, 0xaf, 0x3d, 0xcc, 0xe2, 0xe8, 0xb4, 0xf3, 0xab, 0x06, 0x7a, 0x3d, 0x99,
	0x1d, 0x98, 0x76, 0xb9, 0x6f, 0xa3, 0x3c, 0xa4, 0xa3, 0x59, 0x97, 0xc1, 0x69, 0xc7, 0x46, 0x6d,
	0xc8, 0x45, 0x63, 0x8e, 0x78, 0x7c, 0xc8, 0x64, 0x38, 0xe7, 0x6e, 0x1d, 0x55, 0x34, 0x2b, 0xab,
	0x0a, 0x03, 0x3d, 0x81, 0x45, 0x21, 0x89, 0x1c, 0x0a, 0x35, 0x0b, 0xf3, 0x7b, 0x1f, 0x19, 0x13,
	0x73, 0xdd, 0x98, 0x8c, 0xab, 0xad, 0xcc, 0x71, 0xe4, 0x86, 0xee, 0xc1, 0x92, 0x1c, 0x59, 0x7d,
	0x22, 0xfa, 0xe1, 0x78, 0xc4, 0x8b, 0x72, 0x74, 0x48, 0x44, 0x7f, 0xe7, 0x72, 0x01, 0x0a, 0x27,
	0xac, 0xc3, 0x99, 0x1d, 0x4c, 0x82, 0xd9, 0x29, 0x3d, 0x4e, 0xd8, 0xd3, 0x8a, 0xfd, 0xc1, 0x14,
	0xfb, 0x04, 0xc2, 0x04, 0xf9, 0x73, 0x28, 0x08, 0x69, 0x49, 0x7e, 0x46, 0x59, 0x5c, 0x94, 0x85,
	0x7f, 0x55, 0x94, 0x9c, 0x90, 0xc7, 0x01, 0x4a, 0x54, 0x95, 0xa9, 0x52, 0x67, 0xe6, 0x50, 0xea,
	0xef, 0x61, 0x73, 0x18, 0x67, 0x63, 0x75, 0xb9, 0x37, 0x70, 0xa9, 0xfa, 0xa4, 0x83, 0xb5, 0xa7,
	0xb6, 0xc2, 0xca, 0xde, 0x96, 0x11, 0xee, 0x44, 0x23, 0xde, 0x89, 0xc6, 0x71, 0xbc, 0x13, 0x6b,
	0xd9, 0x80, 0xfc, 0xe5, 0x1f, 0xdb, 0x1a, 0xbe, 0x97, 0xc0, 0xec, 0x27, 0x28, 0x81, 0x1d, 0xfa,
	0x04, 0x8a, 0x43, 0x36, 0xb6, 0xb7, 0xe2, 0xc6, 0xa8, 0x85, 0x81, 0xd1, 0xb8, 0xee, 0x58, 0x35,
	0x09, 0x3d, 0x86, 0xff, 0x85, 0x60, 0xd4, 0x8e, 0xca, 0x28, 0x2e, 0x28, 0x1d, 0x24, 0x9e, 0x6a,
	0x49, 0xe0, 0x52, 0x6c, 0xa3, 0x6a, 0xd4, 0x0e, 0x2c, 0x42, 0xff, 0x9d, 0xbf, 0x35, 0xd0, 0xc7,
	0x2e, 0xd0, 0xec, 0x2e, 0x6f, 0x41, 0x36, 0xb8, 0xc1, 0xd4, 0xa3, 0x7e, 0xb4, 0x9b, 0x93, 0xf3,
	0x7f, 0xaa, 0x83, 0x3b, 0x3f, 0x6a, 0xb0, 0xd2, 0x76, 0x89, 0xe8, 0x7f, 0x20, 0xd1, 0x2f, 0x20,
	0xa3, 0x9a, 0x99, 0xbe, 0x45, 0x33, 0x95, 0x07, 0xfa, 0x18, 0xd6, 0xce, 0x89, 0xeb, 0xd8, 0x44,
	0x72, 0x3f, 0xd9, 0xae, 0xe1, 0xeb, 0x44, 0x4f, 0x14, 0xd1, 0x1e, 0x7d, 0x74, 0x0a, 0x1b, 0xb3,
	0x2f, 0x25, 0x2a, 0x41, 0xf1, 0x18, 0x57, 0x5b, 0xed, 0xaf, 0x4d, 0x6c, 0x35, 0x5a, 0xd6, 0x33,
	0x7c, 0x74, 0x80, 0xcd, 0x76, 0x5b, 0x4f, 0xa1, 0x22, 0xe8, 0x75, 0xb3, 0x69, 0x1e, 0x54, 0x8f,
	0x1b, 0x47, 0x2d, 0xeb, 0x9b, 0x13, 0xf3, 0xc4, 0xd4, 0x35, 0xb4, 0x01, 0x68, 0x4c, 0x5a, 0xc5,
	0xfb, 0x87, 0x8d, 0xe7, 0xa6, 0x9e, 0xde, 0xca, 0xfc, 0xf4, 0x4b, 0x39, 0xf5, 0xe8, 0x67, 0x0d,
	0xee, 0xce, 0xbc, 0x7f, 0x8a, 0xa7, 0xda, 0x6c, 0x7e, 0xdb, 0x68, 0x1d, 0x58, 0xd8, 0xac, 0x9b,
	0x4f, 0x9f, 0x05, 0x00, 0x01, 0xcf, 0x3a, 0x14, 0x4e, 0x5a, 0xb5, 0xa3, 0x56, 0x3d, 0x50, 0xc5,
	0x34, 0x9b, 0x70, 0xf7, 0x5a, 0x38, 0x1e, 0x57, 0x1a, 0xad, 0x42, 0x36, 0x54, 0x99, 0x75, 0x7d,
	0x01, 0xe5, 0x60, 0x79, 0xbf, 0x59, 0x6d, 0x3c, 0xad, 0xd6, 0x9a, 0xa6, 0x9e, 0x41, 0x2b, 0xb0,
	0x14, 0xc7, 0x74, 0x27, 0x8c, 0xa9, 0xd6, 0x7c, 0x7d, 0x59, 0xd6, 0xde, 0x5c, 0x96, 0xb5, 0x3f,
	0x2f, 0xcb, 0xda, 0xcb, 0xab, 0x72, 0xea, 0xcd, 0x55, 0x39, 0xf5, 0xdb, 0x55, 0x39, 0xf5, 0x62,
	0x6f, 0xac, 0xa5, 0x6d, 0x35, 0x45, 0x76, 0x9b, 0xa4, 0x23, 0x2a, 0xd1, 0x3b, 0xf6, 0xfc, 0xd3,
	0xcf, 0x2b, 0xa3, 0xeb, 0xd7, 0xac, 0x6a, 0x71, 0x67, 0x51, 0xb5, 0xe6, 0xb3, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xb0, 0x2f, 0x4b, 0xae, 0xed, 0x0a, 0x00, 0x00,
}

func (m *HostZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostZone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostZone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Halted {
		i--
		if m.Halted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size := m.DelegatedBalance.Size()
		i -= size
		if _, err := m.DelegatedBalance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MaxInnerRedemptionRate.Size()
		i -= size
		if _, err := m.MaxInnerRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinInnerRedemptionRate.Size()
		i -= size
		if _, err := m.MinInnerRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MaxRedemptionRate.Size()
		i -= size
		if _, err := m.MaxRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MinRedemptionRate.Size()
		i -= size
		if _, err := m.MinRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.RedemptionRate.Size()
		i -= size
		if _, err := m.RedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.LastRedemptionRate.Size()
		i -= size
		if _, err := m.LastRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.ClaimAddress) > 0 {
		i -= len(m.ClaimAddress)
		copy(dAtA[i:], m.ClaimAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ClaimAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RedemptionAddress) > 0 {
		i -= len(m.RedemptionAddress)
		copy(dAtA[i:], m.RedemptionAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.RedemptionAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DepositAddress) > 0 {
		i -= len(m.DepositAddress)
		copy(dAtA[i:], m.DepositAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.DepositAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RewardAddress) > 0 {
		i -= len(m.RewardAddress)
		copy(dAtA[i:], m.RewardAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.RewardAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DelegationAddress) > 0 {
		i -= len(m.DelegationAddress)
		copy(dAtA[i:], m.DelegationAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.DelegationAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TransferChannelId) > 0 {
		i -= len(m.TransferChannelId)
		copy(dAtA[i:], m.TransferChannelId)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.TransferChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NativeDenom) > 0 {
		i -= len(m.NativeDenom)
		copy(dAtA[i:], m.NativeDenom)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.NativeDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnbondedTokenSweepTxHash) > 0 {
		i -= len(m.UnbondedTokenSweepTxHash)
		copy(dAtA[i:], m.UnbondedTokenSweepTxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.UnbondedTokenSweepTxHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UndelegationTxHash) > 0 {
		i -= len(m.UndelegationTxHash)
		copy(dAtA[i:], m.UndelegationTxHash)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.UndelegationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UnbondingCompletionTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnbondingCompletionTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintStaketia(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.StTokenAmount.Size()
		i -= size
		if _, err := m.StTokenAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedemptionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedemptionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedemptionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NativeAmount.Size()
		i -= size
		if _, err := m.NativeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.StTokenAmount.Size()
		i -= size
		if _, err := m.StTokenAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaketia(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Redeemer) > 0 {
		i -= len(m.Redeemer)
		copy(dAtA[i:], m.Redeemer)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.Redeemer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlashRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintStaketia(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Time):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintStaketia(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintStaketia(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStaketia(dAtA []byte, offset int, v uint64) int {
	offset -= sovStaketia(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HostZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.NativeDenom)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.TransferChannelId)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.DelegationAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.RewardAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.DepositAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.RedemptionAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.ClaimAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = m.LastRedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.RedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.MinRedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.MaxRedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.MinInnerRedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.MaxInnerRedemptionRate.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.DelegatedBalance.Size()
	n += 1 + l + sovStaketia(uint64(l))
	if m.Halted {
		n += 3
	}
	return n
}

func (m *DelegationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	if m.Status != 0 {
		n += 1 + sovStaketia(uint64(m.Status))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func (m *UnbondingRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	if m.Status != 0 {
		n += 1 + sovStaketia(uint64(m.Status))
	}
	l = m.StTokenAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnbondingCompletionTime)
	n += 1 + l + sovStaketia(uint64(l))
	l = len(m.UndelegationTxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = len(m.UnbondedTokenSweepTxHash)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func (m *RedemptionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	l = len(m.Redeemer)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	l = m.StTokenAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	l = m.NativeAmount.Size()
	n += 1 + l + sovStaketia(uint64(l))
	return n
}

func (m *SlashRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStaketia(uint64(m.Id))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovStaketia(uint64(l))
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovStaketia(uint64(l))
	}
	return n
}

func sovStaketia(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStaketia(x uint64) (n int) {
	return sovStaketia(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HostZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedemptionAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInnerRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinInnerRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInnerRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInnerRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatedBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DelegatedBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Halted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Halted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DelegationRecordStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UnbondingRecordStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StTokenAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UnbondingCompletionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UndelegationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedTokenSweepTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondedTokenSweepTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedemptionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedemptionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedemptionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redeemer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redeemer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StTokenAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NativeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaketia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaketia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaketia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStaketia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStaketia(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStaketia
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaketia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStaketia
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStaketia
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStaketia
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStaketia        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStaketia          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStaketia = fmt.Errorf("proto: unexpected end of group")
)
