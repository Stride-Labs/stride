// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stride/stakeibc/host_zone.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CommunityPoolRebate stores the size of the community pool liquid stake
// (denominated in stTokens) and the rebate rate as a decimal
type CommunityPoolRebate struct {
	// Rebate percentage as a decimal (e.g. 0.2 for 20%)
	RebateRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=rebate_rate,json=rebateRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"rebate_rate"`
	// Number of stTokens received from the community pool liquid stake
	LiquidStakedStTokenAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=liquid_staked_st_token_amount,json=liquidStakedStTokenAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"liquid_staked_st_token_amount"`
}

func (m *CommunityPoolRebate) Reset()         { *m = CommunityPoolRebate{} }
func (m *CommunityPoolRebate) String() string { return proto.CompactTextString(m) }
func (*CommunityPoolRebate) ProtoMessage()    {}
func (*CommunityPoolRebate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f81bf5b42c61245a, []int{0}
}
func (m *CommunityPoolRebate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommunityPoolRebate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommunityPoolRebate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommunityPoolRebate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommunityPoolRebate.Merge(m, src)
}
func (m *CommunityPoolRebate) XXX_Size() int {
	return m.Size()
}
func (m *CommunityPoolRebate) XXX_DiscardUnknown() {
	xxx_messageInfo_CommunityPoolRebate.DiscardUnknown(m)
}

var xxx_messageInfo_CommunityPoolRebate proto.InternalMessageInfo

// Core data structure to track liquid staking zones
type HostZone struct {
	// Chain ID of the host zone
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Bech32 prefix of host zone's address
	Bech32Prefix string `protobuf:"bytes,17,opt,name=bech32prefix,proto3" json:"bech32prefix,omitempty"`
	// ConnectionID from Stride to the host zone (ID is on the stride side)
	ConnectionId string `protobuf:"bytes,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Transfer Channel ID from Stride to the host zone (ID is on the stride side)
	TransferChannelId string `protobuf:"bytes,12,opt,name=transfer_channel_id,json=transferChannelId,proto3" json:"transfer_channel_id,omitempty"`
	// ibc denom of the host zone's native token on stride
	IbcDenom string `protobuf:"bytes,8,opt,name=ibc_denom,json=ibcDenom,proto3" json:"ibc_denom,omitempty"`
	// native denom on host zone
	HostDenom string `protobuf:"bytes,9,opt,name=host_denom,json=hostDenom,proto3" json:"host_denom,omitempty"`
	// The unbonding period in days (e.g. 21)
	UnbondingPeriod uint64 `protobuf:"varint,26,opt,name=unbonding_period,json=unbondingPeriod,proto3" json:"unbonding_period,omitempty"`
	// List of validators that are delegated to
	Validators []*Validator `protobuf:"bytes,3,rep,name=validators,proto3" json:"validators,omitempty"`
	// Address that custodies native tokens during a liquid stake
	DepositAddress string `protobuf:"bytes,18,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	// ICA Address on the host zone responsible for collecting rewards
	WithdrawalIcaAddress string `protobuf:"bytes,22,opt,name=withdrawal_ica_address,json=withdrawalIcaAddress,proto3" json:"withdrawal_ica_address,omitempty"`
	// ICA Address on the host zone responsible for commission
	FeeIcaAddress string `protobuf:"bytes,23,opt,name=fee_ica_address,json=feeIcaAddress,proto3" json:"fee_ica_address,omitempty"`
	// ICA Address on the host zone responsible for staking and unstaking
	DelegationIcaAddress string `protobuf:"bytes,24,opt,name=delegation_ica_address,json=delegationIcaAddress,proto3" json:"delegation_ica_address,omitempty"`
	// ICA Address that receives unstaked tokens after they've finished unbonding
	RedemptionIcaAddress string `protobuf:"bytes,25,opt,name=redemption_ica_address,json=redemptionIcaAddress,proto3" json:"redemption_ica_address,omitempty"`
	// ICA Address that receives tokens from a community pool to liquid stake or
	// redeem In the case of a liquid stake, the community pool deposits native
	// tokens In the case of a redemption, the community pool deposits stTokens
	CommunityPoolDepositIcaAddress string `protobuf:"bytes,30,opt,name=community_pool_deposit_ica_address,json=communityPoolDepositIcaAddress,proto3" json:"community_pool_deposit_ica_address,omitempty"`
	// ICA Address that distributes tokens back to the community pool during a
	// community pool liquid stake or redeem In the case of a liquid stake, the
	// return address sends back stTokens In the case of a redemption, the return
	// address sends back native tokens
	CommunityPoolReturnIcaAddress string `protobuf:"bytes,31,opt,name=community_pool_return_ica_address,json=communityPoolReturnIcaAddress,proto3" json:"community_pool_return_ica_address,omitempty"`
	// Module account on Stride that receives native tokens from the deposit ICA
	// and liquid stakes them
	CommunityPoolStakeHoldingAddress string `protobuf:"bytes,32,opt,name=community_pool_stake_holding_address,json=communityPoolStakeHoldingAddress,proto3" json:"community_pool_stake_holding_address,omitempty"`
	// Module account on Stride that receives stTokens from the deposit ICA and
	// redeems them
	CommunityPoolRedeemHoldingAddress string `protobuf:"bytes,33,opt,name=community_pool_redeem_holding_address,json=communityPoolRedeemHoldingAddress,proto3" json:"community_pool_redeem_holding_address,omitempty"`
	// Optional community pool address to send tokens to after a community pool
	// liquid stake or redemption If this address is empty, the tokens are sent to
	// the main community pool
	CommunityPoolTreasuryAddress string `protobuf:"bytes,35,opt,name=community_pool_treasury_address,json=communityPoolTreasuryAddress,proto3" json:"community_pool_treasury_address,omitempty"`
	// The total delegated balance on the host zone
	TotalDelegations github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,13,opt,name=total_delegations,json=totalDelegations,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_delegations"`
	// The redemption rate from the previous epoch
	LastRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=last_redemption_rate,json=lastRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"last_redemption_rate"`
	// The current redemption rate
	RedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=redemption_rate,json=redemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"redemption_rate"`
	// The min outer redemption rate bound - controlled only be governance
	// The min inner bound cannot exceed this bound
	MinRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,20,opt,name=min_redemption_rate,json=minRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_redemption_rate"`
	// The max outer redemption rate bound - controlled only be governance
	// The max inner bound cannot exceed this bound
	MaxRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,21,opt,name=max_redemption_rate,json=maxRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_redemption_rate"`
	// The min minner redemption rate bound - controlled by the admin
	// If the redemption rate exceeds this bound, the host zone is halted
	MinInnerRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,28,opt,name=min_inner_redemption_rate,json=minInnerRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_inner_redemption_rate"`
	// The max minner redemption rate bound - controlled by the admin
	// If the redemption rate exceeds this bound, the host zone is halted
	MaxInnerRedemptionRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,29,opt,name=max_inner_redemption_rate,json=maxInnerRedemptionRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_inner_redemption_rate"`
	// The max number of messages that can be sent in a delegation
	// or undelegation ICA tx
	MaxMessagesPerIcaTx uint64 `protobuf:"varint,36,opt,name=max_messages_per_ica_tx,json=maxMessagesPerIcaTx,proto3" json:"max_messages_per_ica_tx,omitempty"`
	// Indicates whether redemptions are allowed through this module
	RedemptionsEnabled bool `protobuf:"varint,37,opt,name=redemptions_enabled,json=redemptionsEnabled,proto3" json:"redemptions_enabled,omitempty"`
	// An optional fee rebate
	// If there is no rebate for the host zone, this will be nil
	CommunityPoolRebate *CommunityPoolRebate `protobuf:"bytes,34,opt,name=community_pool_rebate,json=communityPoolRebate,proto3" json:"community_pool_rebate,omitempty"`
	// A boolean indicating whether the chain has LSM enabled
	LsmLiquidStakeEnabled bool `protobuf:"varint,27,opt,name=lsm_liquid_stake_enabled,json=lsmLiquidStakeEnabled,proto3" json:"lsm_liquid_stake_enabled,omitempty"`
	// A boolean indicating whether the chain is currently halted
	Halted bool `protobuf:"varint,19,opt,name=halted,proto3" json:"halted,omitempty"`
}

func (m *HostZone) Reset()         { *m = HostZone{} }
func (m *HostZone) String() string { return proto.CompactTextString(m) }
func (*HostZone) ProtoMessage()    {}
func (*HostZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_f81bf5b42c61245a, []int{1}
}
func (m *HostZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostZone.Merge(m, src)
}
func (m *HostZone) XXX_Size() int {
	return m.Size()
}
func (m *HostZone) XXX_DiscardUnknown() {
	xxx_messageInfo_HostZone.DiscardUnknown(m)
}

var xxx_messageInfo_HostZone proto.InternalMessageInfo

func (m *HostZone) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *HostZone) GetBech32Prefix() string {
	if m != nil {
		return m.Bech32Prefix
	}
	return ""
}

func (m *HostZone) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *HostZone) GetTransferChannelId() string {
	if m != nil {
		return m.TransferChannelId
	}
	return ""
}

func (m *HostZone) GetIbcDenom() string {
	if m != nil {
		return m.IbcDenom
	}
	return ""
}

func (m *HostZone) GetHostDenom() string {
	if m != nil {
		return m.HostDenom
	}
	return ""
}

func (m *HostZone) GetUnbondingPeriod() uint64 {
	if m != nil {
		return m.UnbondingPeriod
	}
	return 0
}

func (m *HostZone) GetValidators() []*Validator {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *HostZone) GetDepositAddress() string {
	if m != nil {
		return m.DepositAddress
	}
	return ""
}

func (m *HostZone) GetWithdrawalIcaAddress() string {
	if m != nil {
		return m.WithdrawalIcaAddress
	}
	return ""
}

func (m *HostZone) GetFeeIcaAddress() string {
	if m != nil {
		return m.FeeIcaAddress
	}
	return ""
}

func (m *HostZone) GetDelegationIcaAddress() string {
	if m != nil {
		return m.DelegationIcaAddress
	}
	return ""
}

func (m *HostZone) GetRedemptionIcaAddress() string {
	if m != nil {
		return m.RedemptionIcaAddress
	}
	return ""
}

func (m *HostZone) GetCommunityPoolDepositIcaAddress() string {
	if m != nil {
		return m.CommunityPoolDepositIcaAddress
	}
	return ""
}

func (m *HostZone) GetCommunityPoolReturnIcaAddress() string {
	if m != nil {
		return m.CommunityPoolReturnIcaAddress
	}
	return ""
}

func (m *HostZone) GetCommunityPoolStakeHoldingAddress() string {
	if m != nil {
		return m.CommunityPoolStakeHoldingAddress
	}
	return ""
}

func (m *HostZone) GetCommunityPoolRedeemHoldingAddress() string {
	if m != nil {
		return m.CommunityPoolRedeemHoldingAddress
	}
	return ""
}

func (m *HostZone) GetCommunityPoolTreasuryAddress() string {
	if m != nil {
		return m.CommunityPoolTreasuryAddress
	}
	return ""
}

func (m *HostZone) GetMaxMessagesPerIcaTx() uint64 {
	if m != nil {
		return m.MaxMessagesPerIcaTx
	}
	return 0
}

func (m *HostZone) GetRedemptionsEnabled() bool {
	if m != nil {
		return m.RedemptionsEnabled
	}
	return false
}

func (m *HostZone) GetCommunityPoolRebate() *CommunityPoolRebate {
	if m != nil {
		return m.CommunityPoolRebate
	}
	return nil
}

func (m *HostZone) GetLsmLiquidStakeEnabled() bool {
	if m != nil {
		return m.LsmLiquidStakeEnabled
	}
	return false
}

func (m *HostZone) GetHalted() bool {
	if m != nil {
		return m.Halted
	}
	return false
}

func init() {
	proto.RegisterType((*CommunityPoolRebate)(nil), "stride.stakeibc.CommunityPoolRebate")
	proto.RegisterType((*HostZone)(nil), "stride.stakeibc.HostZone")
}

func init() { proto.RegisterFile("stride/stakeibc/host_zone.proto", fileDescriptor_f81bf5b42c61245a) }

var fileDescriptor_f81bf5b42c61245a = []byte{
	// 999 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0x41, 0x6f, 0xdb, 0x36,
	0x14, 0xc7, 0xe3, 0xd6, 0x4d, 0x15, 0xa6, 0x89, 0x65, 0x39, 0x49, 0x95, 0xb4, 0x71, 0x9c, 0x34,
	0x1d, 0xbc, 0x43, 0x6c, 0xc0, 0x1d, 0x50, 0x60, 0xd8, 0x61, 0x69, 0x33, 0xa0, 0x36, 0xb2, 0x2e,
	0x50, 0x82, 0x61, 0xe8, 0x0e, 0x02, 0x25, 0xbe, 0xd8, 0x5c, 0x24, 0xd2, 0x23, 0xe9, 0xc6, 0xd9,
	0xa7, 0xd8, 0x87, 0xe9, 0x87, 0xe8, 0xb1, 0xe8, 0xa9, 0xd8, 0xa1, 0x18, 0x92, 0xcf, 0xb0, 0xfb,
	0x20, 0x4a, 0xb2, 0x65, 0x2b, 0x83, 0xd1, 0xc1, 0x27, 0x8b, 0xef, 0x3d, 0xfe, 0x7f, 0x7c, 0xe6,
	0xd3, 0xd3, 0x43, 0x3b, 0x52, 0x09, 0x4a, 0xa0, 0x29, 0x15, 0xbe, 0x00, 0xea, 0xf9, 0xcd, 0x1e,
	0x97, 0xca, 0xfd, 0x83, 0x33, 0x68, 0xf4, 0x05, 0x57, 0xdc, 0x2a, 0xc5, 0x01, 0x8d, 0x34, 0x60,
	0x6b, 0xd3, 0xe7, 0x32, 0xe4, 0xd2, 0xd5, 0xee, 0x66, 0xbc, 0x88, 0x63, 0xb7, 0xd6, 0xba, 0xbc,
	0xcb, 0x63, 0x7b, 0xf4, 0x94, 0x58, 0x73, 0x88, 0xb7, 0x38, 0xa0, 0x04, 0x2b, 0x2e, 0xe2, 0x80,
	0xbd, 0x4f, 0x05, 0x54, 0x79, 0xc9, 0xc3, 0x70, 0xc0, 0xa8, 0xba, 0x3a, 0xe1, 0x3c, 0x70, 0xc0,
	0xc3, 0x0a, 0xac, 0x9f, 0xd0, 0xb2, 0xd0, 0x4f, 0xae, 0xc0, 0x0a, 0xec, 0x42, 0xad, 0x50, 0x5f,
	0x7a, 0xd1, 0x78, 0xff, 0x79, 0x67, 0xe1, 0xaf, 0xcf, 0x3b, 0x5f, 0x75, 0xa9, 0xea, 0x0d, 0xbc,
	0x86, 0xcf, 0xc3, 0xe4, 0x10, 0xc9, 0xcf, 0x81, 0x24, 0x17, 0x4d, 0x75, 0xd5, 0x07, 0xd9, 0x38,
	0x02, 0xdf, 0x41, 0xb1, 0x84, 0x13, 0x09, 0xf6, 0xd1, 0x76, 0x40, 0x7f, 0x1f, 0x50, 0xe2, 0xea,
	0xb3, 0x44, 0x3f, 0xae, 0xe2, 0x17, 0xc0, 0x5c, 0x1c, 0xf2, 0x01, 0x53, 0xf6, 0x9d, 0x2f, 0x46,
	0xb4, 0x99, 0x72, 0x36, 0x63, 0xd1, 0x53, 0xad, 0x79, 0xaa, 0xce, 0x22, 0xc5, 0x43, 0x2d, 0xb8,
	0xf7, 0x4f, 0x19, 0x19, 0xaf, 0xb8, 0x54, 0x6f, 0x38, 0x03, 0x6b, 0x13, 0x19, 0x7e, 0x0f, 0x53,
	0xe6, 0x52, 0x12, 0x27, 0xe3, 0xdc, 0xd7, 0xeb, 0x36, 0xb1, 0xf6, 0xd0, 0x03, 0x0f, 0xfc, 0xde,
	0xb3, 0x56, 0x5f, 0xc0, 0x39, 0x1d, 0xda, 0x65, 0xed, 0x9e, 0xb0, 0x59, 0x4f, 0xd0, 0x8a, 0xcf,
	0x19, 0x03, 0x5f, 0x51, 0xae, 0x35, 0xee, 0xc4, 0x41, 0x63, 0x63, 0x9b, 0x58, 0x0d, 0x54, 0x51,
	0x02, 0x33, 0x79, 0x0e, 0xc2, 0xf5, 0x7b, 0x98, 0x31, 0x08, 0xa2, 0xd0, 0x07, 0x3a, 0xb4, 0x9c,
	0xba, 0x5e, 0xc6, 0x9e, 0x36, 0xb1, 0x1e, 0xa1, 0x25, 0xea, 0xf9, 0x2e, 0x01, 0xc6, 0x43, 0xdb,
	0xd0, 0x51, 0x06, 0xf5, 0xfc, 0xa3, 0x68, 0x6d, 0x6d, 0x23, 0xa4, 0xcb, 0x21, 0xf6, 0x2e, 0x69,
	0xef, 0x52, 0x64, 0x89, 0xdd, 0x5f, 0x23, 0x73, 0xc0, 0x3c, 0xce, 0x08, 0x65, 0x5d, 0xb7, 0x0f,
	0x82, 0x72, 0x62, 0x6f, 0xd5, 0x0a, 0xf5, 0xa2, 0x53, 0x1a, 0xd9, 0x4f, 0xb4, 0xd9, 0xfa, 0x16,
	0xa1, 0xd1, 0xad, 0x4b, 0xfb, 0x6e, 0xed, 0x6e, 0x7d, 0xb9, 0xb5, 0xd5, 0x98, 0x2a, 0xad, 0xc6,
	0xcf, 0x69, 0x88, 0x93, 0x89, 0xb6, 0x0e, 0x51, 0x89, 0x40, 0x9f, 0x4b, 0xaa, 0x5c, 0x4c, 0x88,
	0x00, 0x29, 0x6d, 0x4b, 0xdf, 0x93, 0xfd, 0xf1, 0xdd, 0xc1, 0x5a, 0x52, 0x80, 0x87, 0xb1, 0xe7,
	0x54, 0x09, 0xca, 0xba, 0xce, 0x6a, 0xb2, 0x21, 0xb1, 0x5a, 0xaf, 0xd1, 0xc6, 0x25, 0x55, 0x3d,
	0x22, 0xf0, 0x25, 0x0e, 0x5c, 0xea, 0xe3, 0x91, 0xd2, 0xc6, 0x0c, 0xa5, 0xb5, 0xf1, 0xbe, 0xb6,
	0x8f, 0x53, 0xbd, 0xef, 0x51, 0xe9, 0x1c, 0x60, 0x42, 0xe8, 0xe1, 0x0c, 0xa1, 0x95, 0x73, 0x80,
	0x8c, 0xc2, 0x6b, 0xb4, 0x41, 0x20, 0x80, 0x2e, 0x8e, 0x2f, 0x33, 0x23, 0x64, 0xcf, 0x3a, 0xd1,
	0x78, 0xdf, 0xa4, 0x9e, 0x00, 0x02, 0x61, 0x3f, 0xa7, 0xb7, 0x39, 0x4b, 0x6f, 0xbc, 0x2f, 0xa3,
	0x47, 0xd0, 0x9e, 0x9f, 0xbe, 0x92, 0x6e, 0x9f, 0xf3, 0xc0, 0x4d, 0xef, 0x20, 0xab, 0x5d, 0x9d,
	0xa1, 0x5d, 0xf5, 0xb3, 0xaf, 0xf5, 0x51, 0xac, 0x90, 0xa1, 0x78, 0x68, 0x77, 0x8a, 0x22, 0x40,
	0x0d, 0xc4, 0x64, 0x02, 0x3b, 0x33, 0x20, 0xdb, 0xfe, 0x64, 0xef, 0x88, 0x04, 0x32, 0x8c, 0x1e,
	0xda, 0x9f, 0x62, 0xe8, 0x7a, 0x73, 0x7b, 0x3c, 0xd0, 0x85, 0x9b, 0x62, 0x6a, 0x33, 0x30, 0xb5,
	0x09, 0x8c, 0x7e, 0xd9, 0x5f, 0xc5, 0x12, 0x29, 0xe9, 0x37, 0xf4, 0x34, 0x97, 0x0d, 0x01, 0x08,
	0x73, 0xa8, 0xdd, 0x19, 0xa8, 0xdd, 0xa9, 0x8c, 0x22, 0x91, 0x29, 0x96, 0x8b, 0x76, 0xa6, 0x58,
	0x4a, 0x00, 0x96, 0x03, 0x71, 0x35, 0xa2, 0x3c, 0x99, 0x41, 0x79, 0x3c, 0x41, 0x39, 0x4b, 0xb6,
	0xa7, 0x80, 0x5f, 0x51, 0x59, 0x71, 0x85, 0xa3, 0x7b, 0x4f, 0xcb, 0x4d, 0xda, 0x2b, 0xff, 0xab,
	0x3f, 0x9a, 0x5a, 0xe8, 0x68, 0xac, 0x63, 0x31, 0xb4, 0x16, 0x60, 0xa9, 0xdc, 0x4c, 0xc9, 0xea,
	0x16, 0x8f, 0xb4, 0xfe, 0x77, 0x5f, 0xd6, 0xe2, 0x3f, 0xbe, 0x3b, 0x40, 0x49, 0x82, 0x51, 0xc3,
	0xb7, 0x22, 0x65, 0x67, 0x24, 0xac, 0x1b, 0x3f, 0xa0, 0xd2, 0x34, 0x6a, 0x79, 0x0e, 0xa8, 0x55,
	0x31, 0x89, 0x09, 0x50, 0x25, 0xa4, 0x2c, 0x97, 0xd5, 0xda, 0x1c, 0x50, 0xe5, 0x90, 0x32, 0x27,
	0x4f, 0xc3, 0xc3, 0x1c, 0x6d, 0x7d, 0x2e, 0x34, 0x3c, 0x9c, 0xa2, 0x5d, 0xa2, 0xcd, 0x28, 0x37,
	0xca, 0x18, 0x88, 0x1c, 0xf3, 0xf1, 0x1c, 0x98, 0x1b, 0x21, 0x65, 0xed, 0x48, 0xfd, 0x16, 0x30,
	0x1e, 0xfe, 0x07, 0x78, 0x7b, 0x2e, 0x60, 0x3c, 0xbc, 0x0d, 0xfc, 0x0d, 0x7a, 0x18, 0x81, 0x43,
	0x90, 0x12, 0x77, 0x41, 0x46, 0x5f, 0x38, 0xdd, 0x97, 0xd4, 0xd0, 0xde, 0xd7, 0x5f, 0xb9, 0xe8,
	0xef, 0xff, 0x31, 0xf1, 0x9e, 0x80, 0x68, 0xfb, 0xf8, 0x6c, 0x68, 0x35, 0x51, 0x65, 0x7c, 0x48,
	0xe9, 0x02, 0xc3, 0x5e, 0x00, 0xc4, 0x7e, 0x5a, 0x2b, 0xd4, 0x0d, 0xc7, 0xca, 0xb8, 0x7e, 0x88,
	0x3d, 0xd6, 0x2f, 0x68, 0x3d, 0xd7, 0x35, 0xa2, 0x89, 0xc5, 0xde, 0xab, 0x15, 0xea, 0xcb, 0xad,
	0xfd, 0xdc, 0x57, 0xf2, 0x96, 0x51, 0xc9, 0xa9, 0xf8, 0xb7, 0xcc, 0x4f, 0xcf, 0x91, 0x1d, 0xc8,
	0xd0, 0xcd, 0x8e, 0x3c, 0xa3, 0xf3, 0x3c, 0xd2, 0xe7, 0x59, 0x0f, 0x64, 0x78, 0x3c, 0x1e, 0x5e,
	0xd2, 0x23, 0x6d, 0xa0, 0xc5, 0x1e, 0x0e, 0x14, 0x10, 0xbb, 0xa2, 0xc3, 0x92, 0x55, 0xa7, 0x68,
	0x14, 0xcd, 0x7b, 0x9d, 0xa2, 0x71, 0xcf, 0x5c, 0xec, 0x14, 0x8d, 0x45, 0xf3, 0x7e, 0xa7, 0x68,
	0xdc, 0x37, 0x8d, 0x4e, 0xd1, 0x58, 0x35, 0x4b, 0x9d, 0xa2, 0x51, 0x32, 0xcd, 0x4e, 0xd1, 0x30,
	0xcd, 0xf2, 0x8b, 0xe3, 0xf7, 0xd7, 0xd5, 0xc2, 0x87, 0xeb, 0x6a, 0xe1, 0xef, 0xeb, 0x6a, 0xe1,
	0xcf, 0x9b, 0xea, 0xc2, 0x87, 0x9b, 0xea, 0xc2, 0xa7, 0x9b, 0xea, 0xc2, 0x9b, 0x56, 0xe6, 0x8e,
	0x4e, 0x75, 0x66, 0x07, 0xc7, 0xd8, 0x93, 0xcd, 0x64, 0x48, 0x7c, 0xdb, 0x7a, 0xde, 0x1c, 0x8e,
	0x47, 0x45, 0x7d, 0x67, 0xde, 0xa2, 0x9e, 0x13, 0x9f, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x07,
	0x10, 0x49, 0x01, 0xad, 0x0a, 0x00, 0x00,
}

func (m *CommunityPoolRebate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityPoolRebate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommunityPoolRebate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LiquidStakedStTokenAmount.Size()
		i -= size
		if _, err := m.LiquidStakedStTokenAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.RebateRate.Size()
		i -= size
		if _, err := m.RebateRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HostZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostZone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostZone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RedemptionsEnabled {
		i--
		if m.RedemptionsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.MaxMessagesPerIcaTx != 0 {
		i = encodeVarintHostZone(dAtA, i, uint64(m.MaxMessagesPerIcaTx))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if len(m.CommunityPoolTreasuryAddress) > 0 {
		i -= len(m.CommunityPoolTreasuryAddress)
		copy(dAtA[i:], m.CommunityPoolTreasuryAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.CommunityPoolTreasuryAddress)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.CommunityPoolRebate != nil {
		{
			size, err := m.CommunityPoolRebate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHostZone(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.CommunityPoolRedeemHoldingAddress) > 0 {
		i -= len(m.CommunityPoolRedeemHoldingAddress)
		copy(dAtA[i:], m.CommunityPoolRedeemHoldingAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.CommunityPoolRedeemHoldingAddress)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.CommunityPoolStakeHoldingAddress) > 0 {
		i -= len(m.CommunityPoolStakeHoldingAddress)
		copy(dAtA[i:], m.CommunityPoolStakeHoldingAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.CommunityPoolStakeHoldingAddress)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.CommunityPoolReturnIcaAddress) > 0 {
		i -= len(m.CommunityPoolReturnIcaAddress)
		copy(dAtA[i:], m.CommunityPoolReturnIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.CommunityPoolReturnIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.CommunityPoolDepositIcaAddress) > 0 {
		i -= len(m.CommunityPoolDepositIcaAddress)
		copy(dAtA[i:], m.CommunityPoolDepositIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.CommunityPoolDepositIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	{
		size := m.MaxInnerRedemptionRate.Size()
		i -= size
		if _, err := m.MaxInnerRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	{
		size := m.MinInnerRedemptionRate.Size()
		i -= size
		if _, err := m.MinInnerRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if m.LsmLiquidStakeEnabled {
		i--
		if m.LsmLiquidStakeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.UnbondingPeriod != 0 {
		i = encodeVarintHostZone(dAtA, i, uint64(m.UnbondingPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.RedemptionIcaAddress) > 0 {
		i -= len(m.RedemptionIcaAddress)
		copy(dAtA[i:], m.RedemptionIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.RedemptionIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.DelegationIcaAddress) > 0 {
		i -= len(m.DelegationIcaAddress)
		copy(dAtA[i:], m.DelegationIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.DelegationIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.FeeIcaAddress) > 0 {
		i -= len(m.FeeIcaAddress)
		copy(dAtA[i:], m.FeeIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.FeeIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.WithdrawalIcaAddress) > 0 {
		i -= len(m.WithdrawalIcaAddress)
		copy(dAtA[i:], m.WithdrawalIcaAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.WithdrawalIcaAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	{
		size := m.MaxRedemptionRate.Size()
		i -= size
		if _, err := m.MaxRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size := m.MinRedemptionRate.Size()
		i -= size
		if _, err := m.MinRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	if m.Halted {
		i--
		if m.Halted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.DepositAddress) > 0 {
		i -= len(m.DepositAddress)
		copy(dAtA[i:], m.DepositAddress)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.DepositAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Bech32Prefix) > 0 {
		i -= len(m.Bech32Prefix)
		copy(dAtA[i:], m.Bech32Prefix)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.Bech32Prefix)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	{
		size := m.TotalDelegations.Size()
		i -= size
		if _, err := m.TotalDelegations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.TransferChannelId) > 0 {
		i -= len(m.TransferChannelId)
		copy(dAtA[i:], m.TransferChannelId)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.TransferChannelId)))
		i--
		dAtA[i] = 0x62
	}
	{
		size := m.RedemptionRate.Size()
		i -= size
		if _, err := m.RedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.LastRedemptionRate.Size()
		i -= size
		if _, err := m.LastRedemptionRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintHostZone(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.HostDenom) > 0 {
		i -= len(m.HostDenom)
		copy(dAtA[i:], m.HostDenom)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.HostDenom)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.IbcDenom) > 0 {
		i -= len(m.IbcDenom)
		copy(dAtA[i:], m.IbcDenom)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.IbcDenom)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHostZone(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintHostZone(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintHostZone(dAtA []byte, offset int, v uint64) int {
	offset -= sovHostZone(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CommunityPoolRebate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RebateRate.Size()
	n += 1 + l + sovHostZone(uint64(l))
	l = m.LiquidStakedStTokenAmount.Size()
	n += 1 + l + sovHostZone(uint64(l))
	return n
}

func (m *HostZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovHostZone(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovHostZone(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovHostZone(uint64(l))
		}
	}
	l = len(m.IbcDenom)
	if l > 0 {
		n += 1 + l + sovHostZone(uint64(l))
	}
	l = len(m.HostDenom)
	if l > 0 {
		n += 1 + l + sovHostZone(uint64(l))
	}
	l = m.LastRedemptionRate.Size()
	n += 1 + l + sovHostZone(uint64(l))
	l = m.RedemptionRate.Size()
	n += 1 + l + sovHostZone(uint64(l))
	l = len(m.TransferChannelId)
	if l > 0 {
		n += 1 + l + sovHostZone(uint64(l))
	}
	l = m.TotalDelegations.Size()
	n += 1 + l + sovHostZone(uint64(l))
	l = len(m.Bech32Prefix)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.DepositAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	if m.Halted {
		n += 3
	}
	l = m.MinRedemptionRate.Size()
	n += 2 + l + sovHostZone(uint64(l))
	l = m.MaxRedemptionRate.Size()
	n += 2 + l + sovHostZone(uint64(l))
	l = len(m.WithdrawalIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.FeeIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.DelegationIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.RedemptionIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	if m.UnbondingPeriod != 0 {
		n += 2 + sovHostZone(uint64(m.UnbondingPeriod))
	}
	if m.LsmLiquidStakeEnabled {
		n += 3
	}
	l = m.MinInnerRedemptionRate.Size()
	n += 2 + l + sovHostZone(uint64(l))
	l = m.MaxInnerRedemptionRate.Size()
	n += 2 + l + sovHostZone(uint64(l))
	l = len(m.CommunityPoolDepositIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.CommunityPoolReturnIcaAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.CommunityPoolStakeHoldingAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.CommunityPoolRedeemHoldingAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	if m.CommunityPoolRebate != nil {
		l = m.CommunityPoolRebate.Size()
		n += 2 + l + sovHostZone(uint64(l))
	}
	l = len(m.CommunityPoolTreasuryAddress)
	if l > 0 {
		n += 2 + l + sovHostZone(uint64(l))
	}
	if m.MaxMessagesPerIcaTx != 0 {
		n += 2 + sovHostZone(uint64(m.MaxMessagesPerIcaTx))
	}
	if m.RedemptionsEnabled {
		n += 3
	}
	return n
}

func sovHostZone(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHostZone(x uint64) (n int) {
	return sovHostZone(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommunityPoolRebate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostZone
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityPoolRebate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityPoolRebate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebateRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RebateRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidStakedStTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidStakedStTokenAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHostZone(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHostZone
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHostZone
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &Validator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDelegations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDelegations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Halted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Halted = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawalIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegationIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedemptionIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingPeriod", wireType)
			}
			m.UnbondingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LsmLiquidStakeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LsmLiquidStakeEnabled = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInnerRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinInnerRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInnerRedemptionRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInnerRedemptionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolDepositIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityPoolDepositIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolReturnIcaAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityPoolReturnIcaAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolStakeHoldingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityPoolStakeHoldingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolRedeemHoldingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityPoolRedeemHoldingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolRebate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityPoolRebate == nil {
				m.CommunityPoolRebate = &CommunityPoolRebate{}
			}
			if err := m.CommunityPoolRebate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityPoolTreasuryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHostZone
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHostZone
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityPoolTreasuryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMessagesPerIcaTx", wireType)
			}
			m.MaxMessagesPerIcaTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMessagesPerIcaTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedemptionsEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHostZone(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHostZone
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHostZone(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHostZone
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHostZone
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHostZone
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHostZone
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHostZone
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHostZone        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHostZone          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHostZone = fmt.Errorf("proto: unexpected end of group")
)
